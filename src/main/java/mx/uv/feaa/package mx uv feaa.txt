//Clase Main 
package mx.uv.feaa;

import mx.uv.feaa.model.Usuario;
import mx.uv.feaa.model.Apostador;
import mx.uv.feaa.model.Criador;
import mx.uv.feaa.servicios.AutenticacionService;
import mx.uv.feaa.servicios.UsuarioService;
import mx.uv.feaa.servicios.ManejadorDatos;
import mx.uv.feaa.excepciones.CredencialesInvalidasException;
import mx.uv.feaa.excepciones.UsuarioNoEncontradoException;

import java.util.Scanner;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public class Main {
    private static final Scanner scanner = new Scanner(System.in);
    private static AutenticacionService authService;
    private static UsuarioService usuarioService;
    private static ManejadorDatos manejadorDatos;
    private static Usuario usuarioActual; // Para mantener la sesi√≥n

    public static void main(String[] args) {
        System.out.println("=== Iniciando Sistema de Carreras ===");

        // Inicializar servicios
        inicializarServicios();

        // Verificar integridad de datos
        verificarIntegridadSistema();

        // Bucle principal del men√∫
        ejecutarMenuPrincipal();
    }

    /**
     * Inicializa todos los servicios necesarios
     */
    private static void inicializarServicios() {
        try {
            System.out.println("Inicializando servicios...");

            // Inicializar servicios en orden
            manejadorDatos = ManejadorDatos.getInstance();
            usuarioService = UsuarioService.getInstance();
            authService = new AutenticacionService();

            // Cargar datos existentes
            usuarioService.cargarDatos();

            System.out.println("‚úì Servicios inicializados correctamente");

        } catch (Exception e) {
            System.err.println("Error al inicializar servicios: " + e.getMessage());
            System.exit(1);
        }
    }

    /**
     * Verifica la integridad del sistema y muestra estad√≠sticas
     */
    private static void verificarIntegridadSistema() {
        try {
            // Verificar archivos cr√≠ticos
            if (!manejadorDatos.verificarIntegridadArchivo("usuarios.json")) {
                System.out.println("‚ö† Archivo de usuarios no encontrado o corrupto. Se crear√° uno nuevo.");
            }

            // Mostrar estad√≠sticas del sistema
            Map<String, Object> stats = usuarioService.obtenerEstadisticas();
            System.out.println("\n=== Estado del Sistema ===");
            System.out.println("Total usuarios: " + stats.get("totalUsuarios"));
            System.out.println("Usuarios activos: " + stats.get("usuariosActivos"));
            System.out.println("Criadores: " + stats.get("totalCriadores"));
            System.out.println("Apostadores: " + stats.get("totalApostadores"));

            // Informaci√≥n de espacio
            System.out.println("\n" + manejadorDatos.obtenerInfoEspacio());

        } catch (Exception e) {
            System.err.println("Error al verificar integridad: " + e.getMessage());
        }
    }

    /**
     * Ejecuta el men√∫ principal del sistema
     */
    private static void ejecutarMenuPrincipal() {
        while (true) {
            try {
                mostrarMenuPrincipal();
                int opcion = leerOpcion();

                switch (opcion) {
                    case 1:
                        iniciarSesion();
                        break;
                    case 2:
                        registrarUsuario();
                        break;
                    case 3:
                        mostrarEstadisticasSistema();
                        break;
                    case 4:
                        menuMantenimiento();
                        break;
                    case 5:
                        salirDelSistema();
                        return;
                    default:
                        System.out.println("‚ùå Opci√≥n no v√°lida. Intente nuevamente.");
                }

            } catch (Exception e) {
                System.err.println("Error en men√∫ principal: " + e.getMessage());
                pausar();
            }
        }
    }

    /**
     * Muestra el men√∫ principal
     */
    private static void mostrarMenuPrincipal() {
        System.out.println("\n" + "=".repeat(50));
        System.out.println("    üèá SISTEMA DE CARRERAS DE CABALLOS üèá");
        System.out.println("=".repeat(50));
        System.out.println("1. üîë Iniciar sesi√≥n");
        System.out.println("2. üìù Registrarse");
        System.out.println("3. üìä Ver estad√≠sticas del sistema");
        System.out.println("4. üîß Men√∫ de mantenimiento");
        System.out.println("5. üö™ Salir");
        System.out.println("=".repeat(50));
        System.out.print("Seleccione una opci√≥n: ");
    }

    /**
     * Maneja el proceso de inicio de sesi√≥n
     */
    private static void iniciarSesion() {
        System.out.println("\n=== üîë INICIAR SESI√ìN ===");

        try {
            System.out.print("Nombre de usuario: ");
            String username = scanner.nextLine().trim();

            if (username.isEmpty()) {
                System.out.println("‚ùå El nombre de usuario no puede estar vac√≠o.");
                return;
            }

            System.out.print("Contrase√±a: ");
            String password = scanner.nextLine();

            // Intentar login
            String tipoUsuario = authService.login(username, password);
            usuarioActual = usuarioService.buscarUsuarioPorNombre(username);

            System.out.println("‚úì ¬°Bienvenido, " + username + "!");
            System.out.println("Tipo de usuario: " + tipoUsuario);

            // Redirigir seg√∫n tipo
            switch (tipoUsuario) {
                case "Apostador":
                    menuApostador();
                    break;
                case "Criador":
                    menuCriador();
                    break;
                default:
                    System.out.println("‚ùå Tipo de usuario no reconocido.");
            }

        } catch (UsuarioNoEncontradoException | CredencialesInvalidasException e) {
            System.out.println("‚ùå Error de autenticaci√≥n: " + e.getMessage());
            pausar();
        }
    }

    /**
     * Maneja el proceso de registro de usuario
     */
    private static void registrarUsuario() {
        System.out.println("\n=== üìù REGISTRO DE USUARIO ===");

        try {
            // Seleccionar tipo de usuario
            System.out.println("Tipos de usuario disponibles:");
            System.out.println("1. üéØ Apostador");
            System.out.println("2. üêé Criador");
            System.out.print("Seleccione tipo de usuario: ");

            int tipo = leerOpcion();

            if (tipo < 1 || tipo > 2) {
                System.out.println("‚ùå Tipo de usuario no v√°lido.");
                return;
            }

            // Datos b√°sicos
            System.out.print("Nombre de usuario: ");
            String username = scanner.nextLine().trim();

            if (usuarioService.existeUsuario(username)) {
                System.out.println("‚ùå El nombre de usuario ya est√° en uso.");
                return;
            }

            System.out.print("Email: ");
            String email = scanner.nextLine().trim();

            if (usuarioService.existeEmail(email)) {
                System.out.println("‚ùå El email ya est√° registrado.");
                return;
            }

            System.out.print("Contrase√±a: ");
            String password = scanner.nextLine();

            Usuario nuevoUsuario = null;

            // Crear usuario seg√∫n tipo
            switch (tipo) {
                case 1: // Apostador
                    nuevoUsuario = crearApostador(username, email, password);
                    break;
                case 2: // Criador
                    nuevoUsuario = crearCriador(username, email, password);
                    break;
            }

            if (nuevoUsuario != null) {
                if (usuarioService.registrarUsuario(nuevoUsuario)) {
                    System.out.println("‚úì ¬°Usuario registrado exitosamente!");
                    System.out.println("ID asignado: " + nuevoUsuario.getId());
                } else {
                    System.out.println("‚ùå Error al registrar usuario.");
                }
            }

        } catch (Exception e) {
            System.err.println("Error en registro: " + e.getMessage());
        }

        pausar();
    }

    /**
     * Crea un nuevo apostador con datos espec√≠ficos
     */
    private static Apostador crearApostador(String username, String email, String password) {
        System.out.println("\n--- Datos del Apostador ---");

        System.out.print("Nombre completo: ");
        String nombre = scanner.nextLine().trim();

        System.out.print("Tel√©fono: ");
        String telefono = scanner.nextLine().trim();

        Apostador apostador = new Apostador(username, email, nombre, telefono);
        apostador.setPassword(password);

        return apostador;
    }

    /**
     * Crea un nuevo criador con datos espec√≠ficos
     */
    private static Criador crearCriador(String username, String email, String password) {
        System.out.println("\n--- Datos del Criador ---");

        System.out.print("Licencia de criador: ");
        String licencia = scanner.nextLine().trim();

        // Verificar que la licencia no est√© en uso
        if (usuarioService.buscarCriadorPorLicencia(licencia) != null) {
            System.out.println("‚ùå La licencia ya est√° registrada.");
            return null;
        }

        System.out.print("Nombre del haras: ");
        String haras = scanner.nextLine().trim();

        System.out.print("Direcci√≥n: ");
        String direccion = scanner.nextLine().trim();

        System.out.print("Tel√©fono: ");
        String telefono = scanner.nextLine().trim();

        // Fecha de vencimiento de licencia (1 a√±o por defecto)
        LocalDate vencimientoLicencia = LocalDate.now().plusYears(1);

        Criador criador = new Criador(username, email, licencia, vencimientoLicencia,
                direccion, telefono, haras);
        criador.setPassword(password);

        return criador;
    }

    /**
     * Men√∫ espec√≠fico para apostadores
     */
    private static void menuApostador() {
        while (usuarioActual != null) {
            System.out.println("\n=== üéØ MEN√ö APOSTADOR ===");
            System.out.println("Usuario: " + usuarioActual.getNombreUsuario());
            System.out.println("1. üë§ Ver perfil");
            System.out.println("2. üí∞ Gestionar saldo");
            System.out.println("3. üèá Ver carreras disponibles");
            System.out.println("4. üé≤ Realizar apuesta");
            System.out.println("5. üìà Ver historial de apuestas");
            System.out.println("6. üîÑ Actualizar perfil");
            System.out.println("7. üö™ Cerrar sesi√≥n");
            System.out.print("Seleccione una opci√≥n: ");

            int opcion = leerOpcion();

            switch (opcion) {
                case 1:
                    mostrarPerfilUsuario();
                    break;
                case 2:
                    System.out.println("üöß Gesti√≥n de saldo - En desarrollo");
                    break;
                case 3:
                    System.out.println("üöß Carreras disponibles - En desarrollo");
                    break;
                case 4:
                    System.out.println("üöß Realizar apuesta - En desarrollo");
                    break;
                case 5:
                    System.out.println("üöß Historial de apuestas - En desarrollo");
                    break;
                case 6:
                    actualizarPerfil();
                    break;
                case 7:
                    cerrarSesion();
                    return;
                default:
                    System.out.println("‚ùå Opci√≥n no v√°lida.");
            }

            pausar();
        }
    }

    /**
     * Men√∫ espec√≠fico para criadores
     */
    private static void menuCriador() {
        while (usuarioActual != null) {
            System.out.println("\n=== üêé MEN√ö CRIADOR ===");
            System.out.println("Usuario: " + usuarioActual.getNombreUsuario());
            System.out.println("Haras: " + ((Criador) usuarioActual).getNombreHaras());
            System.out.println("1. üë§ Ver perfil");
            System.out.println("2. üê¥ Gestionar caballos");
            System.out.println("3. üèÅ Inscribir en carreras");
            System.out.println("4. üìä Ver estad√≠sticas");
            System.out.println("5. üìú Ver historial de carreras");
            System.out.println("6. üîÑ Actualizar perfil");
            System.out.println("7. üö™ Cerrar sesi√≥n");
            System.out.print("Seleccione una opci√≥n: ");

            int opcion = leerOpcion();

            switch (opcion) {
                case 1:
                    mostrarPerfilUsuario();
                    break;
                case 2:
                    System.out.println("üöß Gesti√≥n de caballos - En desarrollo");
                    break;
                case 3:
                    System.out.println("üöß Inscripci√≥n en carreras - En desarrollo");
                    break;
                case 4:
                    System.out.println("üöß Estad√≠sticas - En desarrollo");
                    break;
                case 5:
                    System.out.println("üöß Historial de carreras - En desarrollo");
                    break;
                case 6:
                    actualizarPerfil();
                    break;
                case 7:
                    cerrarSesion();
                    return;
                default:
                    System.out.println("‚ùå Opci√≥n no v√°lida.");
            }

            pausar();
        }
    }

    /**
     * Muestra el perfil del usuario actual
     */
    private static void mostrarPerfilUsuario() {
        if (usuarioActual == null) return;

        System.out.println("\n=== üë§ PERFIL DE USUARIO ===");
        System.out.println("ID: " + usuarioActual.getId());
        System.out.println("Nombre de usuario: " + usuarioActual.getNombreUsuario());
        System.out.println("Email: " + usuarioActual.getEmail());
        System.out.println("Tipo: " + usuarioActual.getTipoUsuario());
        System.out.println("Estado: " + (usuarioActual.isActivo() ? "Activo" : "Inactivo"));
        System.out.println("√öltimo acceso: " + usuarioActual.getUltimoAcceso());

        if (usuarioActual instanceof Apostador) {
            Apostador apostador = (Apostador) usuarioActual;
            System.out.println("Nombre: " + apostador.getNombreUsuario());
            System.out.println("Tel√©fono: " + apostador.getTelefono());
        } else if (usuarioActual instanceof Criador) {
            Criador criador = (Criador) usuarioActual;
            System.out.println("Licencia: " + criador.getLicenciaCriador());
            System.out.println("Haras: " + criador.getNombreHaras());
            System.out.println("Direcci√≥n: " + criador.getDireccion());
            System.out.println("Tel√©fono: " + criador.getTelefono());
            System.out.println("Vencimiento licencia: " + criador.getFechaVigenciaLicencia());
        }
    }

    /**
     * Permite actualizar el perfil del usuario
     */
    private static void actualizarPerfil() {
        if (usuarioActual == null) return;

        System.out.println("\n=== üîÑ ACTUALIZAR PERFIL ===");
        System.out.println("Presione Enter para mantener el valor actual");

        try {
            System.out.print("Email actual (" + usuarioActual.getEmail() + "): ");
            String nuevoEmail = scanner.nextLine().trim();
            if (!nuevoEmail.isEmpty()) {
                if (!usuarioService.existeEmail(nuevoEmail) || nuevoEmail.equals(usuarioActual.getEmail())) {
                    usuarioActual.setEmail(nuevoEmail);
                } else {
                    System.out.println("‚ùå El email ya est√° en uso.");
                    return;
                }
            }

            // Campos espec√≠ficos seg√∫n tipo de usuario
            if (usuarioActual instanceof Apostador) {
                actualizarPerfilApostador((Apostador) usuarioActual);
            } else if (usuarioActual instanceof Criador) {
                actualizarPerfilCriador((Criador) usuarioActual);
            }

            // Guardar cambios
            if (usuarioService.actualizarUsuario(usuarioActual)) {
                System.out.println("‚úì Perfil actualizado exitosamente.");
            } else {
                System.out.println("‚ùå Error al actualizar perfil.");
            }

        } catch (Exception e) {
            System.err.println("Error al actualizar perfil: " + e.getMessage());
        }
    }

    private static void actualizarPerfilApostador(Apostador apostador) {
        System.out.print("Nombre actual (" + apostador.getNombreUsuario() + "): ");
        String nuevoNombre = scanner.nextLine().trim();
        if (!nuevoNombre.isEmpty()) {
            apostador.getNombre();
        }

        System.out.print("Tel√©fono actual (" + apostador.getTelefono() + "): ");
        String nuevoTelefono = scanner.nextLine().trim();
        if (!nuevoTelefono.isEmpty()) {
            apostador.setTelefono(nuevoTelefono);
        }
    }

    private static void actualizarPerfilCriador(Criador criador) {
        System.out.print("Nombre del haras actual (" + criador.getNombreHaras() + "): ");
        String nuevoHaras = scanner.nextLine().trim();
        if (!nuevoHaras.isEmpty()) {
            criador.setNombreHaras(nuevoHaras);
        }

        System.out.print("Direcci√≥n actual (" + criador.getDireccion() + "): ");
        String nuevaDireccion = scanner.nextLine().trim();
        if (!nuevaDireccion.isEmpty()) {
            criador.setDireccion(nuevaDireccion);
        }

        System.out.print("Tel√©fono actual (" + criador.getTelefono() + "): ");
        String nuevoTelefono = scanner.nextLine().trim();
        if (!nuevoTelefono.isEmpty()) {
            criador.setTelefono(nuevoTelefono);
        }
    }

    /**
     * Muestra estad√≠sticas del sistema
     */
    private static void mostrarEstadisticasSistema() {
        System.out.println("\n=== üìä ESTAD√çSTICAS DEL SISTEMA ===");

        Map<String, Object> stats = usuarioService.obtenerEstadisticas();

        System.out.println("üë• Usuarios registrados: " + stats.get("totalUsuarios"));
        System.out.println("‚úÖ Usuarios activos: " + stats.get("usuariosActivos"));
        System.out.println("üêé Criadores: " + stats.get("totalCriadores") +
                " (Activos: " + stats.get("criadoresActivos") + ")");
        System.out.println("üéØ Apostadores: " + stats.get("totalApostadores") +
                " (Activos: " + stats.get("apostadoresActivos") + ")");

        System.out.println("\n" + manejadorDatos.obtenerInfoEspacio());

        pausar();
    }

    /**
     * Men√∫ de mantenimiento del sistema
     */
    private static void menuMantenimiento() {
        System.out.println("\n=== üîß MEN√ö DE MANTENIMIENTO ===");
        System.out.println("1. üíæ Crear backup manual");
        System.out.println("2. üìã Listar backups");
        System.out.println("3. üóëÔ∏è Limpiar archivos temporales");
        System.out.println("4. üóÇÔ∏è Limpiar backups antiguos");
        System.out.println("5. üîÑ Recargar datos");
        System.out.println("6. üîç Verificar integridad");
        System.out.println("7. üîô Volver al men√∫ principal");
        System.out.print("Seleccione una opci√≥n: ");

        int opcion = leerOpcion();

        switch (opcion) {
            case 1:
                if (usuarioService.guardarDatos()) {
                    System.out.println("‚úì Backup creado exitosamente.");
                } else {
                    System.out.println("‚ùå Error al crear backup.");
                }
                break;
            case 2:
                List<String> backups = manejadorDatos.listarBackups();
                System.out.println("Backups disponibles (" + backups.size() + "):");
                backups.forEach(System.out::println);
                break;
            case 3:
                if (manejadorDatos.limpiarArchivosTemporales()) {
                    System.out.println("‚úì Archivos temporales limpiados.");
                } else {
                    System.out.println("‚ùå Error al limpiar archivos temporales.");
                }
                break;
            case 4:
                System.out.print("¬øCu√°ntos backups mantener? (por defecto 5): ");
                int mantener = leerOpcion();
                if (mantener <= 0) mantener = 5;

                if (manejadorDatos.limpiarBackupsAntiguos(mantener)) {
                    System.out.println("‚úì Backups antiguos limpiados.");
                } else {
                    System.out.println("‚ùå Error al limpiar backups.");
                }
                break;
            case 5:
                if (usuarioService.recargarDatos()) {
                    System.out.println("‚úì Datos recargados exitosamente.");
                } else {
                    System.out.println("‚ùå Error al recargar datos.");
                }
                break;
            case 6:
                verificarIntegridadSistema();
                break;
            case 7:
                return;
            default:
                System.out.println("‚ùå Opci√≥n no v√°lida.");
        }

        pausar();
    }

    /**
     * Cierra la sesi√≥n del usuario actual
     */
    private static void cerrarSesion() {
        if (usuarioActual != null) {
            System.out.println("üëã Sesi√≥n cerrada. ¬°Hasta pronto, " +
                    usuarioActual.getNombreUsuario() + "!");
            usuarioActual = null;
        }
    }

    /**
     * Sale del sistema guardando todos los datos
     */
    private static void salirDelSistema() {
        System.out.println("\nüîÑ Guardando datos antes de salir...");

        if (usuarioService.guardarDatos()) {
            System.out.println("‚úì Datos guardados exitosamente.");
        } else {
            System.out.println("‚ö† Advertencia: No se pudieron guardar todos los datos.");
        }

        System.out.println("üëã ¬°Gracias por usar el Sistema de Carreras!");
        System.out.println("üêé ¬°Que tengas un excelente d√≠a!");
    }

    // ===== M√âTODOS UTILITARIOS =====

    /**
     * Lee una opci√≥n num√©rica del usuario con manejo de errores
     */
    private static int leerOpcion() {
        try {
            int opcion = scanner.nextInt();
            scanner.nextLine(); // Limpiar buffer
            return opcion;
        } catch (Exception e) {
            scanner.nextLine(); // Limpiar buffer en caso de error
            return -1;
        }
    }

    /**
     * Pausa la ejecuci√≥n esperando que el usuario presione Enter
     */
    private static void pausar() {
        System.out.print("\nPresione Enter para continuar...");
        scanner.nextLine();
    }
}

package mx.uv.feaa.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import mx.uv.feaa.excepciones.RepositoryException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Adaptador mejorado para serializaci√≥n/deserializaci√≥n JSON usando Jackson.
 * Soporta tipos Java 8 (LocalDate, LocalDateTime), manejo de colecciones,
 * y funciones espec√≠ficas para repositorios.
 */
public class JsonAdapter {
    private static final ObjectMapper mapper = createObjectMapper();
    private static final Logger logger = Logger.getLogger(JsonAdapter.class.getName());
    private static final String DATA_DIRECTORY = "src/main/resources/data/";

    static {
        // Crear directorio de datos si no existe
        try {
            Files.createDirectories(Paths.get(DATA_DIRECTORY));
        } catch (IOException e) {
            logger.log(Level.WARNING, "No se pudo crear directorio de datos: " + DATA_DIRECTORY, e);
        }
    }

    private static ObjectMapper createObjectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();

        // Registrar m√≥dulo para fechas Java 8
        objectMapper.registerModule(new JavaTimeModule());

        // Configuraci√≥n para fechas
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);

        // Configuraci√≥n para deserializaci√≥n m√°s flexible
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);

        return objectMapper;
    }

    /**
     * Serializa un objeto a JSON (String)
     */
    public static String toJson(Object object) {
        try {
            return mapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            logger.log(Level.SEVERE, "Error al serializar objeto a JSON", e);
            throw new RepositoryException("Error al serializar objeto a JSON: " + e.getMessage(), e);
        }
    }

    /**
     * Deserializa JSON a un objeto del tipo especificado
     */
    public static <T> T fromJson(String json, Class<T> clazz) {
        if (json == null || json.trim().isEmpty()) {
            return null;
        }

        try {
            return mapper.readValue(json, clazz);
        } catch (JsonProcessingException e) {
            logger.log(Level.SEVERE, "Error al deserializar JSON a objeto", e);
            throw new RepositoryException("Error al deserializar JSON: " + e.getMessage(), e);
        }
    }

    /**
     * Deserializa JSON a una lista de objetos
     */
    public static <T> List<T> fromJsonToList(String json, Class<T> clazz) {
        if (json == null || json.trim().isEmpty()) {
            return new ArrayList<>();
        }

        try {
            return mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, clazz));
        } catch (JsonProcessingException e) {
            logger.log(Level.SEVERE, "Error al deserializar JSON a lista", e);
            throw new RepositoryException("Error al deserializar JSON a lista: " + e.getMessage(), e);
        }
    }

    /**
     * Deserializa JSON con tipos complejos (ej. Map<Enum, Object>)
     */
    public static <T> T fromJsonWithTypeReference(String json, TypeReference<T> typeReference) {
        if (json == null || json.trim().isEmpty()) {
            return null;
        }

        try {
            return mapper.readValue(json, typeReference);
        } catch (JsonProcessingException e) {
            logger.log(Level.SEVERE, "Error al deserializar JSON con TypeReference", e);
            throw new RepositoryException("Error al deserializar JSON con TypeReference: " + e.getMessage(), e);
        }
    }

    /**
     * Lee un archivo JSON y lo convierte a objeto
     */
    public static <T> T loadFromFile(String filePath, Class<T> clazz) {
        try {
            File file = new File(resolveFilePath(filePath));

            if (!file.exists()) {
                logger.log(Level.INFO, "Archivo no existe, retornando null: " + filePath);
                return null;
            }

            return mapper.readValue(file, clazz);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al leer archivo JSON: " + filePath, e);
            throw new RepositoryException("Error al leer archivo JSON: " + filePath + " - " + e.getMessage(), e);
        }
    }

    /**
     * Guarda un objeto en archivo JSON
     */
    public static boolean saveToFile(Object object, String filePath) {
        try {
            String fullPath = resolveFilePath(filePath);

            // Crear directorios padre si no existen
            Path path = Paths.get(fullPath);
            Files.createDirectories(path.getParent());

            mapper.writeValue(new File(fullPath), object);
            logger.log(Level.INFO, "Archivo guardado exitosamente: " + fullPath);
            return true;
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al guardar archivo JSON: " + filePath, e);
            throw new RepositoryException("Error al guardar archivo JSON: " + filePath + " - " + e.getMessage(), e);
        }
    }

    // === M√âTODOS ESPEC√çFICOS PARA REPOSITORIOS ===

    /**
     * Carga una lista de objetos desde archivo JSON
     * Si el archivo no existe, retorna una lista vac√≠a
     */
    public static <T> List<T> cargarLista(String filePath, Class<T> clazz) {
        try {
            File file = new File(resolveFilePath(filePath));

            if (!file.exists()) {
                logger.log(Level.INFO, "Archivo no existe, creando lista vac√≠a: " + filePath);
                // Crear archivo vac√≠o con lista vac√≠a
                List<T> listaVacia = new ArrayList<>();
                guardarLista(listaVacia, filePath);
                return listaVacia;
            }

            if (file.length() == 0) {
                logger.log(Level.INFO, "Archivo vac√≠o, retornando lista vac√≠a: " + filePath);
                return new ArrayList<>();
            }

            return mapper.readValue(file, mapper.getTypeFactory().constructCollectionType(List.class, clazz));

        } catch (IOException e) {
            logger.log(Level.WARNING, "Error al cargar lista desde archivo: " + filePath + ", retornando lista vac√≠a", e);
            return new ArrayList<>();
        }
    }

    /**
     * Guarda una lista de objetos en archivo JSON
     */
    public static <T> void guardarLista(List<T> lista, String filePath) {
        if (lista == null) {
            lista = new ArrayList<>();
        }

        try {
            String fullPath = resolveFilePath(filePath);

            // Crear directorios padre si no existen
            Path path = Paths.get(fullPath);
            Files.createDirectories(path.getParent());

            mapper.writeValue(new File(fullPath), lista);
            logger.log(Level.INFO, "Lista guardada exitosamente: " + fullPath + " (" + lista.size() + " elementos)");

        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al guardar lista en archivo: " + filePath, e);
            throw new RepositoryException("Error al guardar lista en archivo: " + filePath + " - " + e.getMessage(), e);
        }
    }

    /**
     * Carga una lista usando TypeReference para tipos complejos
     */
    public static <T> List<T> cargarListaConTipo(String filePath, TypeReference<List<T>> typeReference) {
        try {
            File file = new File(resolveFilePath(filePath));

            if (!file.exists() || file.length() == 0) {
                logger.log(Level.INFO, "Archivo no existe o est√° vac√≠o, retornando lista vac√≠a: " + filePath);
                return new ArrayList<>();
            }

            return mapper.readValue(file, typeReference);

        } catch (IOException e) {
            logger.log(Level.WARNING, "Error al cargar lista con tipo desde archivo: " + filePath + ", retornando lista vac√≠a", e);
            return new ArrayList<>();
        }
    }

    /**
     * Verifica si un archivo JSON existe
     */
    public static boolean existeArchivo(String filePath) {
        return new File(resolveFilePath(filePath)).exists();
    }

    /**
     * Crea un backup del archivo JSON
     */
    public static boolean crearBackup(String filePath) {
        try {
            String fullPath = resolveFilePath(filePath);
            File original = new File(fullPath);

            if (!original.exists()) {
                return false;
            }

            String backupPath = fullPath + ".bak." + System.currentTimeMillis();
            Files.copy(original.toPath(), Paths.get(backupPath));

            logger.log(Level.INFO, "Backup creado: " + backupPath);
            return true;

        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al crear backup: " + filePath, e);
            return false;
        }
    }

    /**
     * Resuelve la ruta completa del archivo
     */
    private static String resolveFilePath(String filePath) {
        // Si la ruta ya es absoluta o comienza con src/, usarla tal como est√°
        if (filePath.startsWith("/") || filePath.startsWith("src/")) {
            return filePath;
        }

        // Si es una ruta relativa, agregar el directorio de datos
        if (!filePath.startsWith(DATA_DIRECTORY)) {
            return DATA_DIRECTORY + filePath;
        }

        return filePath;
    }

    /**
     * Obtiene el ObjectMapper configurado (para uso avanzado)
     */
    public static ObjectMapper getMapper() {
        return mapper;
    }

    /**
     * Valida si una cadena es JSON v√°lido
     */
    public static boolean esJsonValido(String json) {
        if (json == null || json.trim().isEmpty()) {
            return false;
        }

        try {
            mapper.readTree(json);
            return true;
        } catch (JsonProcessingException e) {
            return false;
        }
    }

    /**
     * Formatea JSON de manera legible
     */
    public static String formatearJson(String json) {
        try {
            Object jsonObject = mapper.readValue(json, Object.class);
            return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObject);
        } catch (JsonProcessingException e) {
            logger.log(Level.WARNING, "Error al formatear JSON", e);
            return json;
        }
    }

    /**
     * Obtiene estad√≠sticas del directorio de datos
     */
    public static String obtenerEstadisticasArchivos() {
        File dataDir = new File(DATA_DIRECTORY);

        if (!dataDir.exists()) {
            return "Directorio de datos no existe: " + DATA_DIRECTORY;
        }

        File[] archivos = dataDir.listFiles((dir, name) -> name.endsWith(".json"));

        if (archivos == null) {
            return "No se pueden leer archivos del directorio: " + DATA_DIRECTORY;
        }

        StringBuilder stats = new StringBuilder();
        stats.append("Estad√≠sticas de archivos JSON:\n");
        stats.append("Directorio: ").append(DATA_DIRECTORY).append("\n");
        stats.append("Total de archivos: ").append(archivos.length).append("\n\n");

        for (File archivo : archivos) {
            stats.append("- ").append(archivo.getName())
                    .append(" (").append(archivo.length()).append(" bytes)")
                    .append(" - Modificado: ").append(new java.util.Date(archivo.lastModified()))
                    .append("\n");
        }

        return stats.toString();
    }
}

package mx.uv.feaa.servicios;

import mx.uv.feaa.util.JsonAdapter;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Gestor centralizado para el manejo de archivos JSON y persistencia de datos
 */
public class ManejadorDatos {
    private static final Logger logger = Logger.getLogger(ManejadorDatos.class.getName());

    // Configuraci√≥n de rutas
    private static final String BASE_DIR = "data";
    private static final String BACKUP_DIR = BASE_DIR + "/backup";
    private static final String TEMP_DIR = BASE_DIR + "/temp";
    private static final String LOGS_DIR = BASE_DIR + "/logs";

    // Singleton
    private static ManejadorDatos instance;

    private ManejadorDatos() {
        inicializarEstructuraDirectorios();
    }

    public static ManejadorDatos getInstance() {
        if (instance == null) {
            instance = new ManejadorDatos();
        }
        return instance;
    }

    /**
     * Inicializa la estructura completa de directorios
     */
    private void inicializarEstructuraDirectorios() {
        try {
            crearDirectorio(BASE_DIR);
            crearDirectorio(BACKUP_DIR);
            crearDirectorio(TEMP_DIR);
            crearDirectorio(LOGS_DIR);

            logger.info("Estructura de directorios inicializada correctamente");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error al inicializar directorios", e);
        }
    }

    /**
     * Crea un directorio si no existe
     */
    private void crearDirectorio(String path) {
        File dir = new File(path);
        if (!dir.exists()) {
            if (dir.mkdirs()) {
                logger.info("Directorio creado: " + path);
            } else {
                logger.warning("No se pudo crear el directorio: " + path);
            }
        }
    }

    /**
     * Guarda un objeto en archivo JSON con manejo de errores robusto
     */
    public <T> boolean guardarDatos(T objeto, String nombreArchivo) {
        return guardarDatos(objeto, nombreArchivo, true);
    }

    /**
     * Guarda un objeto en archivo JSON
     */
    public <T> boolean guardarDatos(T objeto, String nombreArchivo, boolean crearBackup) {
        if (objeto == null || nombreArchivo == null || nombreArchivo.trim().isEmpty()) {
            logger.warning("Datos inv√°lidos para guardar");
            return false;
        }

        String rutaCompleta = BASE_DIR + "/" + nombreArchivo;

        try {
            // Crear backup si se solicita y el archivo existe
            if (crearBackup && new File(rutaCompleta).exists()) {
                crearBackupArchivo(rutaCompleta);
            }

            // Guardar en archivo temporal primero
            String rutaTemporal = TEMP_DIR + "/temp_" + nombreArchivo;
            boolean guardadoTemporal = JsonAdapter.saveToFile(objeto, rutaTemporal);

            if (!guardadoTemporal) {
                logger.severe("Error al guardar archivo temporal: " + rutaTemporal);
                return false;
            }

            // Mover el archivo temporal al definitivo
            if (moverArchivo(rutaTemporal, rutaCompleta)) {
                logger.info("Datos guardados exitosamente: " + rutaCompleta);
                return true;
            } else {
                logger.severe("Error al mover archivo temporal a definitivo");
                return false;
            }

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error al guardar datos en: " + rutaCompleta, e);
            return false;
        }
    }

    /**
     * Carga datos desde archivo JSON
     */
    public <T> T cargarDatos(String nombreArchivo, Class<T> clazz) {
        if (nombreArchivo == null || clazz == null) {
            logger.warning("Par√°metros inv√°lidos para cargar datos");
            return null;
        }

        String rutaCompleta = BASE_DIR + "/" + nombreArchivo;

        try {
            File archivo = new File(rutaCompleta);
            if (!archivo.exists()) {
                logger.info("Archivo no encontrado: " + rutaCompleta);
                return null;
            }

            T datos = JsonAdapter.loadFromFile(rutaCompleta, clazz);
            if (datos != null) {
                logger.info("Datos cargados exitosamente desde: " + rutaCompleta);
            } else {
                logger.warning("No se pudieron cargar datos desde: " + rutaCompleta);
            }

            return datos;

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error al cargar datos desde: " + rutaCompleta, e);
            return null;
        }
    }

    /**
     * Carga una lista de objetos desde archivo JSON
     */
    public <T> List<T> cargarListaDatos(String nombreArchivo, Class<T> clazz) {
        if (nombreArchivo == null || clazz == null) {
            logger.warning("Par√°metros inv√°lidos para cargar lista");
            return new ArrayList<>();
        }

        String rutaCompleta = BASE_DIR + "/" + nombreArchivo;

        try {
            File archivo = new File(rutaCompleta);
            if (!archivo.exists()) {
                logger.info("Archivo no encontrado: " + rutaCompleta);
                return new ArrayList<>();
            }

            List<T> datos = JsonAdapter.fromJsonToList(
                    JsonAdapter.loadFromFile(rutaCompleta, String.class), clazz);

            if (datos != null) {
                logger.info("Lista cargada exitosamente desde: " + rutaCompleta +
                        " (" + datos.size() + " elementos)");
                return datos;
            } else {
                logger.warning("No se pudo cargar lista desde: " + rutaCompleta);
                return new ArrayList<>();
            }

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error al cargar lista desde: " + rutaCompleta, e);
            return new ArrayList<>();
        }
    }

    /**
     * Crea un backup de un archivo espec√≠fico
     */
    public boolean crearBackupArchivo(String rutaArchivo) {
        try {
            File archivoOriginal = new File(rutaArchivo);
            if (!archivoOriginal.exists()) {
                return false;
            }

            String timestamp = LocalDateTime.now().format(
                    DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String nombreArchivo = archivoOriginal.getName();
            String nombreSinExtension = nombreArchivo.substring(0, nombreArchivo.lastIndexOf('.'));
            String extension = nombreArchivo.substring(nombreArchivo.lastIndexOf('.'));

            String rutaBackup = BACKUP_DIR + "/" + nombreSinExtension + "_" + timestamp + extension;

            return copiarArchivo(rutaArchivo, rutaBackup);

        } catch (Exception e) {
            logger.log(Level.WARNING, "Error al crear backup de: " + rutaArchivo, e);
            return false;
        }
    }

    /**
     * Restaura un archivo desde un backup
     */
    public boolean restaurarDesdeBackup(String nombreArchivo, String timestampBackup) {
        try {
            String rutaBackup = BACKUP_DIR + "/" + nombreArchivo.replace(".json", "") +
                    "_" + timestampBackup + ".json";
            String rutaDestino = BASE_DIR + "/" + nombreArchivo;

            if (!new File(rutaBackup).exists()) {
                logger.warning("Archivo de backup no encontrado: " + rutaBackup);
                return false;
            }

            return copiarArchivo(rutaBackup, rutaDestino);

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error al restaurar desde backup", e);
            return false;
        }
    }

    /**
     * Lista todos los backups disponibles
     */
    public List<String> listarBackups() {
        List<String> backups = new ArrayList<>();

        try {
            File backupDir = new File(BACKUP_DIR);
            if (backupDir.exists() && backupDir.isDirectory()) {
                File[] archivos = backupDir.listFiles((dir, name) -> name.endsWith(".json"));

                if (archivos != null) {
                    for (File archivo : archivos) {
                        backups.add(archivo.getName());
                    }
                }
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error al listar backups", e);
        }

        return backups;
    }

    /**
     * Limpia archivos temporales antiguos
     */
    public boolean limpiarArchivosTemporales() {
        try {
            File tempDir = new File(TEMP_DIR);
            if (tempDir.exists() && tempDir.isDirectory()) {
                File[] archivos = tempDir.listFiles();

                if (archivos != null) {
                    for (File archivo : archivos) {
                        if (archivo.delete()) {
                            logger.info("Archivo temporal eliminado: " + archivo.getName());
                        }
                    }
                }
            }
            return true;
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error al limpiar archivos temporales", e);
            return false;
        }
    }

    /**
     * Limpia backups antiguos (mantiene solo los √∫ltimos N)
     */
    public boolean limpiarBackupsAntiguos(int mantenerUltimos) {
        try {
            List<String> backups = listarBackups();

            if (backups.size() > mantenerUltimos) {
                // Ordenar por fecha y eliminar los m√°s antiguos
                backups.sort(String::compareTo);

                for (int i = 0; i < backups.size() - mantenerUltimos; i++) {
                    File backup = new File(BACKUP_DIR + "/" + backups.get(i));
                    if (backup.delete()) {
                        logger.info("Backup antiguo eliminado: " + backups.get(i));
                    }
                }
            }

            return true;
        } catch (Exception e) {
            logger.log(Level.WARNING, "Error al limpiar backups antiguos", e);
            return false;
        }
    }

    /**
     * Verifica la integridad de un archivo JSON
     */
    public boolean verificarIntegridadArchivo(String nombreArchivo) {
        try {
            String rutaCompleta = BASE_DIR + "/" + nombreArchivo;
            File archivo = new File(rutaCompleta);

            if (!archivo.exists()) {
                return false;
            }

            // Intentar parsear el JSON
            String contenido = JsonAdapter.loadFromFile(rutaCompleta, String.class);
            return contenido != null && !contenido.trim().isEmpty();

        } catch (Exception e) {
            logger.log(Level.WARNING, "Archivo JSON corrupto: " + nombreArchivo, e);
            return false;
        }
    }

    /**
     * Obtiene informaci√≥n sobre el uso de espacio
     */
    public String obtenerInfoEspacio() {
        try {
            long espacioTotal = calcularTamanoDirectorio(new File(BASE_DIR));
            long espacioBackups = calcularTamanoDirectorio(new File(BACKUP_DIR));
            long espacioTemp = calcularTamanoDirectorio(new File(TEMP_DIR));

            return String.format(
                    "Uso de espacio:\n" +
                            "- Total: %.2f MB\n" +
                            "- Backups: %.2f MB\n" +
                            "- Temporales: %.2f MB\n" +
                            "- Datos: %.2f MB",
                    espacioTotal / 1024.0 / 1024.0,
                    espacioBackups / 1024.0 / 1024.0,
                    espacioTemp / 1024.0 / 1024.0,
                    (espacioTotal - espacioBackups - espacioTemp) / 1024.0 / 1024.0
            );

        } catch (Exception e) {
            logger.log(Level.WARNING, "Error al calcular espacio", e);
            return "No se pudo calcular el uso de espacio";
        }
    }

    // ===== M√âTODOS AUXILIARES =====

    private boolean copiarArchivo(String origen, String destino) {
        try {
            Path origenPath = Paths.get(origen);
            Path destinoPath = Paths.get(destino);

            Files.copy(origenPath, destinoPath,
                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);

            logger.info("Archivo copiado: " + origen + " -> " + destino);
            return true;

        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al copiar archivo", e);
            return false;
        }
    }

    private boolean moverArchivo(String origen, String destino) {
        try {
            Path origenPath = Paths.get(origen);
            Path destinoPath = Paths.get(destino);

            Files.move(origenPath, destinoPath,
                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);

            logger.info("Archivo movido: " + origen + " -> " + destino);
            return true;

        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error al mover archivo", e);
            return false;
        }
    }

    private long calcularTamanoDirectorio(File directorio) {
        long tamano = 0;

        if (directorio.exists() && directorio.isDirectory()) {
            File[] archivos = directorio.listFiles();
            if (archivos != null) {
                for (File archivo : archivos) {
                    if (archivo.isFile()) {
                        tamano += archivo.length();
                    } else if (archivo.isDirectory()) {
                        tamano += calcularTamanoDirectorio(archivo);
                    }
                }
            }
        }

        return tamano;
    }
}

aqui estan mis datos de apostador respetemoslos 
public class Apostador extends Usuario {
    private double saldo;
    private double limiteApuesta;
    private List<Apuesta> historialApuestas;
    private double totalApostado;
    private double totalGanado;
    private int apuestasRealizadas;
    private LocalDate ultimaActividad;

    // Constantes
    private static final double LIMITE_APUESTA_DEFECTO = 1000.0;
    private static final double SALDO_MINIMO = 0.0;
    private static final double APUESTA_MINIMA = 10.0;

    // Constructor
    public Apostador() {
        super();
        this.saldo = 0.0;
        this.limiteApuesta = LIMITE_APUESTA_DEFECTO;
        this.historialApuestas = new ArrayList<>();
        this.totalApostado = 0.0;
        this.totalGanado = 0.0;
        this.apuestasRealizadas = 0;
    }

    public Apostador(String nombreUsuario, String email, String nombre, String telefono) {
        super(nombreUsuario, email);
        this.saldo = 0.0;
        this.limiteApuesta = LIMITE_APUESTA_DEFECTO;
        this.historialApuestas = new ArrayList<>();
        this.totalApostado = 0.0;
        this.totalGanado = 0.0;
        this.apuestasRealizadas = 0;
        // Campos adicionales espec√≠ficos del apostador
        this.setNombre(nombre);
        this.setTelefono(telefono);
    }
    no inclui los metodos de negocio porque esos no los vamos a cambiar 
    
    import mx.uv.feaa.enumeracion.EstadoApuesta;
import mx.uv.feaa.enumeracion.TipoApuesta;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Clase abstracta que representa una apuesta en el sistema
 */
public abstract class Apuesta {
    protected String id;
    protected double montoApostado;
    protected LocalDateTime fechaApuesta;
    protected EstadoApuesta estado;
    protected Carrera carrera;
    protected Apostador apostador;
    protected TipoApuesta tipoApuesta;
    protected Map<String, Object> seleccion;
    protected double cuotaAplicada;
    protected double montoGanado;

    // Constructor
    public Apuesta(String id, Apostador apostador, Carrera carrera,
                   TipoApuesta tipoApuesta, double montoApostado) {
        this.id = id;
        this.apostador = apostador;
        this.carrera = carrera;
        this.tipoApuesta = tipoApuesta;
        this.montoApostado = montoApostado;
        this.fechaApuesta = LocalDateTime.now();
        this.estado = EstadoApuesta.PENDIENTE; // Estado inicial corregido
        this.seleccion = new HashMap<>();
        this.cuotaAplicada = 0.0;
        this.montoGanado = 0.0;
    }

    /**
     * M√©todo abstracto para calcular el dividendo seg√∫n el tipo de apuesta
     */
    public abstract double calcularDividendo(Resultado resultado);

    /**
     * M√©todo abstracto para verificar si la apuesta es ganadora
     */
    public abstract boolean esGanadora(Resultado resultado);
    
    public class Caballo {
    private String id;
    private String nombre;
    private LocalDate fechaNacimiento;
    private SexoCaballo sexo;
    private double peso;
    private String pedigri;
    private LocalDate ultimaCarrera;
    private List<HistorialCarrera> historialCarreras;
    private EstadisticasRendimiento estadisticas;

    // Constructor por defecto
    public Caballo() {
        this.historialCarreras = new ArrayList<>();
        this.estadisticas = new EstadisticasRendimiento();
    }

    // Constructor completo
    public Caballo(String id, String nombre, LocalDate fechaNacimiento,
                   SexoCaballo sexo, double peso, String pedigri) {
        this();
        this.id = id;
        this.nombre = nombre;
        this.fechaNacimiento = fechaNacimiento;
        this.sexo = sexo;
        this.peso = peso;
        this.pedigri = pedigri;
    }

public class Carrera {
    private String id;
    private String nombre;
    private LocalDate fecha;
    private LocalTime hora;
    private String distancia;
    private EstadoCarrera estado;
    private List<Participante> participantes;
    private Resultado resultado;
    private int minimoParticipantes;
    private int maximoParticipantes;

    // Constructor
    public Carrera(String id, String nombre, LocalDate fecha, LocalTime hora, String distancia) {
        this.id = id;
        this.nombre = nombre;
        this.fecha = fecha;
        this.hora = hora;
        this.distancia = distancia;
        this.estado = EstadoCarrera.PROGRAMADA;
        this.participantes = new ArrayList<>();
        this.minimoParticipantes = 4; // M√≠nimo reglamentario
        this.maximoParticipantes = 20; // M√°ximo reglamentario
    }
    
    
    public class Criador extends Usuario {
    private String licenciaCriador;
    private LocalDate fechaVigenciaLicencia;
    private List<Caballo> caballos;
    private String direccion;
    private String telefono;
    private String nombreHaras;
    private int caballosRegistrados;
    private int caballosActivos;

    // Constructor
    public Criador() {
        super();
        this.caballos = new ArrayList<>();
        this.caballosRegistrados = 0;
        this.caballosActivos = 0;
    }

    public Criador(String nombreUsuario, String email, String licenciaCriador,
                   LocalDate fechaVigenciaLicencia, String direccion, String telefono, String nombreHaras) {
        super(nombreUsuario, email);
        this.licenciaCriador = licenciaCriador;
        this.fechaVigenciaLicencia = fechaVigenciaLicencia;
        this.direccion = direccion;
        this.telefono = telefono;
        this.nombreHaras = nombreHaras;
        this.caballos = new ArrayList<>();
        this.caballosRegistrados = 0;
        this.caballosActivos = 0;


package mx.uv.feaa.model;

import java.time.LocalTime;

public class EstadisticasRendimiento {
    private int totalCarreras;
    private int victorias;
    private int colocaciones;
    private LocalTime promedioTiempo;
    private double porcentajeVictorias;

    // Constructor
    public EstadisticasRendimiento() {
        this.totalCarreras = 0;
        this.victorias = 0;
        this.colocaciones = 0;
        this.promedioTiempo = LocalTime.of(0, 0, 0);
        this.porcentajeVictorias = 0.0;
    }

    public EstadisticasRendimiento(int totalCarreras, int victorias, int colocaciones) {
        this.totalCarreras = totalCarreras;
        this.victorias = victorias;
        this.colocaciones = colocaciones;
        this.porcentajeVictorias = totalCarreras > 0 ? (double) victorias / totalCarreras * 100 : 0.0;
    }
    
    
public class HistorialCarrera {
    private String carreraId;
    private String nombreCarrera;
    private Integer posicion;
    private LocalTime tiempo;
    private LocalDate fecha;
    private String hipodromo;

    // Constructor
    public HistorialCarrera(Carrera carrera, Integer posicion, LocalTime tiempo, LocalDate fecha) {}

    public HistorialCarrera(String carreraId, String nombreCarrera, Integer posicion,
                            LocalTime tiempo, LocalDate fecha, String hipodromo) {
        this.carreraId = carreraId;
        this.nombreCarrera = nombreCarrera;
        this.posicion = posicion;
        this.tiempo = tiempo;
        this.fecha = fecha;
        this.hipodromo = hipodromo;
        
        
        package mx.uv.feaa.model;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

public class Jinete {
    private String id;
    private String nombre;
    private LocalDate fechaNacimiento;
    private double peso;
    private String licencia;
    private LocalDate fechaVigenciaLicencia;
    private List<HistorialCarrera> historialCarreras;
    private EstadisticasRendimiento estadisticas;

    // Constantes
    private static final double PESO_MINIMO_JINETE = 50.0; // kg
    private static final double PESO_MAXIMO_JINETE = 57.0; // kg
    private static final int EDAD_MINIMA_JINETE = 16; // a√±os
    
    
    import mx.uv.feaa.enumeracion.EstadoParticipante;

/**
 * Representa un participante en una carrera (combinaci√≥n de jinete y caballo)
 */
public class Participante {
    private int numeroCompetidor;
    private double pesoAsignado;
    private Caballo caballo;
    private Jinete jinete;
    private EstadoParticipante estado;

    // Constructor
    public Participante(int numeroCompetidor, double pesoAsignado, Caballo caballo, Jinete jinete) {
        this.numeroCompetidor = numeroCompetidor;
        this.pesoAsignado = pesoAsignado;
        this.caballo = caballo;
        this.jinete = jinete;
        this.estado = EstadoParticipante.INSCRITO;
    }
    
    public class Resultado {
    private Carrera carrera;
    private Map<Integer, Participante> posiciones;
    private Map<Participante, LocalTime> tiemposOficiales;
    private LocalDate fechaRegistro;

    // Constructor
    public Resultado(Carrera carrera) {
        this.carrera = carrera;
        this.posiciones = new HashMap<>();
        this.tiemposOficiales = new HashMap<>();
        this.fechaRegistro = LocalDate.now();
    }

    /**
     * Registra la posici√≥n de un participante
     */
    public void registrarPosicion(int posicion, Participante participante, LocalTime tiempo) {
        posiciones.put(posicion, participante);
        tiemposOficiales.put(participante, tiempo);
    }
    
    public abstract class Usuario {
    protected String id;
    protected String nombreUsuario;
    protected String email;
    protected String password;
    protected boolean activo;
    @JsonDeserialize (using = LocalDateTimeDeserializer.class)
    protected LocalDateTime fechaRegistro;
    @JsonDeserialize (using = LocalDateTimeDeserializer.class)
    protected LocalDateTime ultimoAcceso;
    protected String tipoUsuario;

    // Constructor por defecto
    public Usuario() {
        this.activo = true;
        this.fechaRegistro = LocalDateTime.now();
        this.ultimoAcceso = LocalDateTime.now();
    }


    // Constructor con par√°metros b√°sicos
    public Usuario(String nombreUsuario, String email) {
        this();
        this.nombreUsuario = nombreUsuario;
        this.email = email;
        this.tipoUsuario = this.getClass().getSimpleName();
    }

    // Constructor completo
    public Usuario(String id, String nombreUsuario, String email, String password) {
        this();
        this.id = id;
        this.nombreUsuario = nombreUsuario;
        this.email = email;
        this.password = password;
        this.tipoUsuario = this.getClass().getSimpleName();
    }
