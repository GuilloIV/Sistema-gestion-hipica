DOC Con todas las clases 

package mx.uv.feaa.enumeracion;

/**
 * Enumeration que define los estados posibles de una carrera
 */
public enum EstadoCarrera {
    PROGRAMADA("Programada"),
    INSCRIPCIONES_ABIERTAS("Inscripciones Abiertas"),
    APUESTAS_ABIERTAS("Apuestas Abiertas"),
    APUESTAS_CERRADAS("Apuestas Cerradas"),
    EN_CURSO("En Curso"),
    FINALIZADA("Finalizada"),
    CANCELADA("Cancelada"),
    SUSPENDIDA("Suspendida");

    private final String descripcion;

    EstadoCarrera(String descripcion) {
        this.descripcion = descripcion;
    }

    public String getDescripcion() {
        return descripcion;
    }

    /**
     * Verifica si se pueden inscribir participantes
     */
    public boolean permiteInscripciones() {
        return this == PROGRAMADA || this == INSCRIPCIONES_ABIERTAS;
    }

    /**
     * Verifica si se pueden realizar apuestas
     */
    public boolean permiteApuestas() {
        return this == APUESTAS_ABIERTAS;
    }

    /**
     * Verifica si la carrera está activa
     */
    public boolean estaActiva() {
        return this != CANCELADA && this != SUSPENDIDA;
    }

    /**
     * Verifica si la carrera ha finalizado
     */
    public boolean haFinalizado() {
        return this == FINALIZADA;
    }

    @Override
    public String toString() {
        return descripcion;
    }
}

package mx.uv.feaa.enumeracion;

/**
 * Enumeration que define los estados posibles de una apuesta
 */
public enum EstadoApuesta {
    PENDIENTE("Pendiente"),
    CONFIRMADA("Confirmada"),
    GANADORA("Ganadora"),
    PERDEDORA("Perdedora"),
    CANCELADA("Cancelada"),
    PAGADA("Pagada"),
    REEMBOLSADA("Reembolsada");

    private final String descripcion;

    EstadoApuesta(String descripcion) {
        this.descripcion = descripcion;
    }

    public String getDescripcion() {
        return descripcion;
    }

    /**
     * Verifica si la apuesta está activa
     */
    public boolean estaActiva() {
        return this == PENDIENTE || this == CONFIRMADA;
    }

    /**
     * Verifica si la apuesta ha sido procesada
     */
    public boolean estaProcesada() {
        return this == GANADORA || this == PERDEDORA || this == PAGADA;
    }

    /**
     * Verifica si la apuesta puede ser cancelada
     */
    public boolean puedeCancelarse() {
        return this == PENDIENTE || this == CONFIRMADA;
    }

    /**
     * Verifica si la apuesta requiere pago
     */
    public boolean requierePago() {
        return this == GANADORA;
    }

    @Override
    public String toString() {
        return descripcion;
    }
}

package mx.uv.feaa.enumeracion;

/**
 * Enumeration que define los estados posibles de un participante
 */
public enum EstadoParticipante {
    INSCRITO("Inscrito"),
    CONFIRMADO("Confirmado"),
    PESADO("Pesado"),
    EN_PISTA("En Pista"),
    DESCALIFICADO("Descalificado"),
    RETIRADO("Retirado"),
    FINALIZADO("Finalizado");

    private final String descripcion;

    EstadoParticipante(String descripcion) {
        this.descripcion = descripcion;
    }

    public String getDescripcion() {
        return descripcion;
    }

    /**
     * Verifica si el participante puede competir
     */
    public boolean puedeParticipar() {
        return this == CONFIRMADO || this == PESADO || this == EN_PISTA;
    }

    /**
     * Verifica si el participante está activo en la carrera
     */
    public boolean estaActivo() {
        return this != DESCALIFICADO && this != RETIRADO;
    }

    /**
     * Verifica si el participante ha completado la carrera
     */
    public boolean haCompletado() {
        return this == FINALIZADO;
    }

    @Override
    public String toString() {
        return descripcion;
    }
}

package mx.uv.feaa.enumeracion;

/**
 * Enumeration que define los sexos de los caballos
 */
public enum SexoCaballo {
    MACHO("Macho"),
    HEMBRA("Hembra"),
    CASTRADO("Castrado");

    private final String descripcion;

    SexoCaballo(String descripcion) {
        this.descripcion = descripcion;
    }

    public String getDescripcion() {
        return descripcion;
    }

    /**
     * Verifica si puede competir en carreras de machos
     */
    public boolean puedeCompeririConMachos() {
        return this == MACHO || this == CASTRADO;
    }

    /**
     * Verifica si puede competir en carreras de hembras
     */
    public boolean puedeCompetirConHembras() {
        return this == HEMBRA;
    }

    /**
     * Verifica si puede competir en carreras mixtas
     */
    public boolean puedeCompetirEnMixtas() {
        return true; // Todos pueden competir en carreras mixtas
    }

    @Override
    public String toString() {
        return descripcion;
    }
}

package mx.uv.feaa.enumeracion;


public enum TipoApuesta {
    GANADOR("Ganador", "Acertar el caballo que llegue en primer lugar"),
    COLOCADO("Colocado", "Acertar un caballo que llegue en los primeros lugares"),
    EXACTA("Exacta", "Acertar los dos primeros caballos en orden exacto"),
    QUINELA("Quinela", "Acertar los dos primeros caballos sin importar el orden"),
    TRIFECTA("Trifecta", "Acertar los tres primeros caballos en orden exacto");

    private final String nombre;
    private final String descripcion;

    TipoApuesta(String nombre, String descripcion) {
        this.nombre = nombre;
        this.descripcion = descripcion;
    }

    public String getNombre() {
        return nombre;
    }

    public String getDescripcion() {
        return descripcion;
    }
}

package mx.uv.feaa.enumeracion;


public enum TipoApuesta {
    GANADOR("Ganador", "Acertar el caballo que llegue en primer lugar"),
    COLOCADO("Colocado", "Acertar un caballo que llegue en los primeros lugares"),
    EXACTA("Exacta", "Acertar los dos primeros caballos en orden exacto"),
    QUINELA("Quinela", "Acertar los dos primeros caballos sin importar el orden"),
    TRIFECTA("Trifecta", "Acertar los tres primeros caballos en orden exacto");

    private final String nombre;
    private final String descripcion;

    TipoApuesta(String nombre, String descripcion) {
        this.nombre = nombre;
        this.descripcion = descripcion;
    }

    public String getNombre() {
        return nombre;
    }

    public String getDescripcion() {
        return descripcion;
    }
}

package mx.uv.feaa.model;

import mx.uv.feaa.enumeracion.EstadoApuesta;
import mx.uv.feaa.enumeracion.TipoApuesta;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Clase abstracta que representa una apuesta en el sistema
 */
public abstract class Apuesta {
    protected String id;
    protected double montoApostado;
    protected LocalDateTime fechaApuesta;
    protected EstadoApuesta estado;
    protected Carrera carrera;
    protected Apostador apostador;
    protected TipoApuesta tipoApuesta;
    protected Map<String, Object> seleccion;
    protected double cuotaAplicada;
    protected double montoGanado;

    // Constructor
    public Apuesta(String id, Apostador apostador, Carrera carrera,
                   TipoApuesta tipoApuesta, double montoApostado) {
        this.id = id;
        this.apostador = apostador;
        this.carrera = carrera;
        this.tipoApuesta = tipoApuesta;
        this.montoApostado = montoApostado;
        this.fechaApuesta = LocalDateTime.now();
        this.estado = EstadoApuesta.PENDIENTE; // Estado inicial corregido
        this.seleccion = new HashMap<>();
        this.cuotaAplicada = 0.0;
        this.montoGanado = 0.0;
    }

    /**
     * Método abstracto para calcular el dividendo según el tipo de apuesta
     */
    public abstract double calcularDividendo(Resultado resultado);

    /**
     * Método abstracto para verificar si la apuesta es ganadora
     */
    public abstract boolean esGanadora(Resultado resultado);

    /**
     * Valida si la apuesta puede ser procesada
     */
    public boolean validarApuesta() {
        // Verificar que el monto sea válido
        if (montoApostado <= 0) {
            return false;
        }

        // Verificar que el apostador tenga saldo suficiente
        if (apostador.getSaldo() < montoApostado) {
            return false;
        }

        // Verificar que la carrera permita apuestas
        if (carrera == null || !carrera.getEstado().permiteApuestas()) {
            return false;
        }

        // Verificar que la selección sea válida
        if (seleccion == null || seleccion.isEmpty()) {
            return false;
        }

        return true;
    }

    /**
     * Procesa el resultado de la apuesta
     */
    public void procesar(Resultado resultado) {
        if (resultado == null || !estado.estaActiva()) { // Verificación corregida
            return;
        }

        if (esGanadora(resultado)) {
            estado = EstadoApuesta.GANADORA;
            montoGanado = calcularDividendo(resultado);
            apostador.acreditarGanancia(montoGanado);
        } else {
            estado = EstadoApuesta.PERDEDORA;
            montoGanado = 0.0;
        }
    }

    /**
     * Cancela la apuesta y devuelve el dinero
     */
    public boolean cancelar() {
        if (estado.puedeCancelarse()) { // Verificación corregida
            estado = EstadoApuesta.CANCELADA;
            apostador.acreditarGanancia(montoApostado); // Devolver el dinero
            return true;
        }
        return false;
    }

    /**
     * Obtiene información resumida de la apuesta
     */
    public String obtenerResumen() {
        return String.format("Apuesta %s: %s - $%.2f - %s",
                id, tipoApuesta.getDescripcion(), montoApostado, estado.getDescripcion());
    }

    // Getters y Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public double getMontoApostado() { return montoApostado; }
    public void setMontoApostado(double montoApostado) {
        if (montoApostado > 0) {
            this.montoApostado = montoApostado;
        }
    }

    public LocalDateTime getFechaApuesta() { return fechaApuesta; }
    public void setFechaApuesta(LocalDateTime fechaApuesta) { this.fechaApuesta = fechaApuesta; }

    public EstadoApuesta getEstado() { return estado; }
    public void setEstado(EstadoApuesta estado) { this.estado = estado; }

    public Carrera getCarrera() { return carrera; }
    public void setCarrera(Carrera carrera) { this.carrera = carrera; }

    public Apostador getApostador() { return apostador; }
    public void setApostador(Apostador apostador) { this.apostador = apostador; }

    public TipoApuesta getTipoApuesta() { return tipoApuesta; }
    public void setTipoApuesta(TipoApuesta tipoApuesta) { this.tipoApuesta = tipoApuesta; }

    public Map<String, Object> getSeleccion() { return new HashMap<>(seleccion); }
    public void setSeleccion(Map<String, Object> seleccion) {
        this.seleccion = seleccion != null ? new HashMap<>(seleccion) : new HashMap<>();
    }

    public double getCuotaAplicada() { return cuotaAplicada; }
    public void setCuotaAplicada(double cuotaAplicada) { this.cuotaAplicada = cuotaAplicada; }

    public double getMontoGanado() { return montoGanado; }
    public void setMontoGanado(double montoGanado) { this.montoGanado = montoGanado; }

    @Override
    public String toString() {
        return String.format("Apuesta{id='%s', tipo=%s, monto=%.2f, estado=%s, fecha=%s}",
                id, tipoApuesta != null ? tipoApuesta.getDescripcion() : "N/A",
                montoApostado, estado != null ? estado.getDescripcion() : "N/A", fechaApuesta);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Apuesta apuesta = (Apuesta) obj;
        return id != null ? id.equals(apuesta.id) : apuesta.id == null;
    }

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }
}

package mx.uv.feaa.model;

import mx.uv.feaa.enumeracion.SexoCaballo;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

public class Caballo {
    private String id;
    private String nombre;
    private LocalDate fechaNacimiento;
    private SexoCaballo sexo;
    private double peso;
    private String pedigri;
    private LocalDate ultimaCarrera;
    private List<HistorialCarrera> historialCarreras;
    private EstadisticasRendimiento estadisticas;

    // Constructor por defecto
    public Caballo() {
        this.historialCarreras = new ArrayList<>();
        this.estadisticas = new EstadisticasRendimiento();
    }

    // Constructor completo
    public Caballo(String id, String nombre, LocalDate fechaNacimiento,
                   SexoCaballo sexo, double peso, String pedigri) {
        this();
        this.id = id;
        this.nombre = nombre;
        this.fechaNacimiento = fechaNacimiento;
        this.sexo = sexo;
        this.peso = peso;
        this.pedigri = pedigri;
    }

    // Métodos de negocio
    public boolean validarDescanso() {
        if (ultimaCarrera == null) {
            return true; // Si nunca ha corrido, puede participar
        }

        LocalDate ahora = LocalDate.now();
        long diasDescanso = ChronoUnit.DAYS.between(ultimaCarrera, ahora);

        // Regla: mínimo 7 días de descanso entre carreras
        return diasDescanso >= 7;
    }

    /**
     * Método sobrecargado sin parámetros - verifica condiciones generales
     */
    public boolean puedeParticipar() {
        // Validar descanso mínimo
        if (!validarDescanso()) {
            return false;
        }

        // Validar edad mínima (2 años para competir)
        LocalDate ahora = LocalDate.now();
        long edadEnAnios = ChronoUnit.YEARS.between(fechaNacimiento, ahora);
        if (edadEnAnios < 2) {
            return false;
        }

        // Validar peso dentro de límites razonables (300-600 kg)
        if (peso < 300 || peso > 600) {
            return false;
        }

        return true;
    }

    /**
     * Método sobrecargado con parámetros - verifica condiciones específicas para una carrera
     */
    public boolean puedeParticipar(Carrera carrera) {
        if (carrera == null) {
            return false;
        }

        // Validaciones generales
        if (!puedeParticipar()) {
            return false;
        }

        // Validar edad específica para la fecha de la carrera
        LocalDate fechaCarrera = carrera.getFecha();
        long edadEnAnios = ChronoUnit.YEARS.between(fechaNacimiento, fechaCarrera);
        if (edadEnAnios < 2) {
            return false;
        }

        // Validar que no esté ya inscrito en la carrera
        for (Participante p : carrera.getParticipantes()) {
            if (this.equals(p.getCaballo())) {
                return false;
            }
        }

        return true;
    }

    public EstadisticasRendimiento obtenerRendimiento() {
        // Recalcular estadísticas basadas en el historial
        int totalCarreras = historialCarreras.size();
        int victorias = (int) historialCarreras.stream()
                .mapToInt(h -> h.esVictoria() ? 1 : 0)
                .sum();
        int colocaciones = (int) historialCarreras.stream()
                .mapToInt(h -> h.esColocacion() ? 1 : 0)
                .sum();

        this.estadisticas = new EstadisticasRendimiento(totalCarreras, victorias, colocaciones);
        return this.estadisticas;
    }

    /**
     * Método corregido para agregar historial
     */
    public void agregarHistorial(HistorialCarrera historial) {
        if (historial != null) {
            this.historialCarreras.add(historial);
            this.ultimaCarrera = historial.getFecha();
            // Actualizar estadísticas
            obtenerRendimiento();
        }
    }

    /**
     * Método alternativo para mantener compatibilidad
     */
    public void agregarHistorialCarrera(HistorialCarrera historial) {
        agregarHistorial(historial);
    }

    public int getEdadEnAnios() {
        return (int) ChronoUnit.YEARS.between(fechaNacimiento, LocalDate.now());
    }

    /**
     * Obtiene la edad del caballo en una fecha específica
     */
    public int getEdadEnAnios(LocalDate fecha) {
        return (int) ChronoUnit.YEARS.between(fechaNacimiento, fecha);
    }

    /**
     * Verifica si el caballo es veterano (más de 8 años)
     */
    public boolean esVeterano() {
        return getEdadEnAnios() > 8;
    }

    /**
     * Verifica si el caballo es debutante (sin carreras)
     */
    public boolean esDebutante() {
        return historialCarreras.isEmpty();
    }

    // Getters y Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }

    public LocalDate getFechaNacimiento() { return fechaNacimiento; }
    public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; }

    public SexoCaballo getSexo() { return sexo; }
    public void setSexo(SexoCaballo sexo) { this.sexo = sexo; }

    public double getPeso() { return peso; }
    public void setPeso(double peso) { this.peso = peso; }

    public String getPedigri() { return pedigri; }
    public void setPedigri(String pedigri) { this.pedigri = pedigri; }

    public LocalDate getUltimaCarrera() { return ultimaCarrera; }
    public void setUltimaCarrera(LocalDate ultimaCarrera) { this.ultimaCarrera = ultimaCarrera; }

    public List<HistorialCarrera> getHistorialCarreras() {
        return new ArrayList<>(historialCarreras);
    }

    public void setHistorialCarreras(List<HistorialCarrera> historialCarreras) {
        this.historialCarreras = historialCarreras != null ?
                new ArrayList<>(historialCarreras) : new ArrayList<>();
    }

    public EstadisticasRendimiento getEstadisticas() { return estadisticas; }
    public void setEstadisticas(EstadisticasRendimiento estadisticas) { this.estadisticas = estadisticas; }

    @Override
    public String toString() {
        return String.format("Caballo{id='%s', nombre='%s', edad=%d años, sexo=%s, peso=%.1f kg, carreras=%d}",
                id, nombre, getEdadEnAnios(), sexo != null ? sexo.getDescripcion() : "N/A",
                peso, historialCarreras.size());
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Caballo caballo = (Caballo) obj;
        return id != null ? id.equals(caballo.id) : caballo.id == null;
    }

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }
}

//Clase Carrera 

package mx.uv.feaa.model;

import mx.uv.feaa.enumeracion.EstadoCarrera;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Representa una carrera de caballos
 */
public class Carrera {
    private String id;
    private String nombre;
    private LocalDate fecha;
    private LocalTime hora;
    private String distancia;
    private EstadoCarrera estado;
    private List<Participante> participantes;
    private Resultado resultado;
    private int minimoParticipantes;
    private int maximoParticipantes;

    // Constructor
    public Carrera(String id, String nombre, LocalDate fecha, LocalTime hora, String distancia) {
        this.id = id;
        this.nombre = nombre;
        this.fecha = fecha;
        this.hora = hora;
        this.distancia = distancia;
        this.estado = EstadoCarrera.PROGRAMADA;
        this.participantes = new ArrayList<>();
        this.minimoParticipantes = 4; // Mínimo reglamentario
        this.maximoParticipantes = 20; // Máximo reglamentario
    }

    /**
     * Agrega un participante a la carrera
     */
    public boolean agregarParticipante(Participante participante) {
        if (!estado.permiteInscripciones()) {
            return false;
        }

        if (participantes.size() >= maximoParticipantes) {
            return false;
        }

        if (!participante.validarElegibilidad()) {
            return false;
        }

        // Verificar que no haya números duplicados
        for (Participante p : participantes) {
            if (p.getNumeroCompetidor() == participante.getNumeroCompetidor()) {
                return false;
            }
        }

        participantes.add(participante);

        // Si se alcanza el mínimo, cambiar estado
        if (participantes.size() >= minimoParticipantes && estado == EstadoCarrera.PROGRAMADA) {
            estado = EstadoCarrera.INSCRIPCIONES_ABIERTAS;
        }

        return true;
    }

    /**
     * Valida que se cumplan las condiciones mínimas para la carrera
     */
    public boolean validarCondicionesMinimas() {
        return participantes.size() >= minimoParticipantes &&
                fecha.isAfter(LocalDate.now().minusDays(1)) &&
                estado.estaActiva();
    }

    /**
     * Registra el resultado de la carrera
     */
    public void registrarResultado(Resultado resultado) {
        if (estado == EstadoCarrera.EN_CURSO || estado == EstadoCarrera.APUESTAS_CERRADAS) {
            this.resultado = resultado;
            this.estado = EstadoCarrera.FINALIZADA;

            // Actualizar historial de participantes
            for (Participante participante : participantes) {
                Integer posicion = resultado.obtenerPosicion(participante);
                LocalTime tiempo = resultado.obtenerTiempo(participante);

                if (posicion != null && tiempo != null) {
                    HistorialCarrera historial = new HistorialCarrera(this, posicion, tiempo, fecha);
                    participante.getCaballo().agregarHistorial(historial);
                    participante.getJinete().agregarHistorial(historial);
                }
            }
        }
    }

    /**
     * Obtiene las cuotas actuales (simulación básica)
     */
    public Map<String, Double> obtenerCuotasActuales() {
        Map<String, Double> cuotas = new HashMap<>();

        for (Participante participante : participantes) {
            // Cuota básica basada en rendimiento histórico
            EstadisticasRendimiento rendimiento = participante.obtenerRendimientoHistorico();
            double cuota = calcularCuotaBasica(rendimiento);
            cuotas.put(participante.getCaballo().getNombre(), cuota);
        }

        return cuotas;
    }

    /**
     * Calcula una cuota básica basada en el rendimiento
     */
    private double calcularCuotaBasica(EstadisticasRendimiento rendimiento) {
        if (rendimiento.getTotalCarreras() == 0) {
            return 10.0; // Cuota por defecto para debutantes
        }

        double porcentajeVictorias = rendimiento.getPorcentajeVictorias();

        if (porcentajeVictorias >= 40) return 2.5;
        else if (porcentajeVictorias >= 25) return 4.0;
        else if (porcentajeVictorias >= 15) return 6.0;
        else if (porcentajeVictorias >= 10) return 8.0;
        else return 12.0;
    }

    /**
     * Inicia las apuestas para la carrera
     */
    public boolean iniciarApuestas() {
        if (validarCondicionesMinimas() &&
                (estado == EstadoCarrera.INSCRIPCIONES_ABIERTAS || estado == EstadoCarrera.PROGRAMADA)) {
            estado = EstadoCarrera.APUESTAS_ABIERTAS;
            return true;
        }
        return false;
    }

    /**
     * Cierra las apuestas para la carrera
     */
    public boolean cerrarApuestas() {
        if (estado == EstadoCarrera.APUESTAS_ABIERTAS) {
            estado = EstadoCarrera.APUESTAS_CERRADAS;
            return true;
        }
        return false;
    }

    /**
     * Inicia la carrera
     */
    public boolean iniciarCarrera() {
        if (estado == EstadoCarrera.APUESTAS_CERRADAS && validarCondicionesMinimas()) {
            estado = EstadoCarrera.EN_CURSO;
            return true;
        }
        return false;
    }

    // Getters y Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }

    public LocalDate getFecha() { return fecha; }
    public void setFecha(LocalDate fecha) { this.fecha = fecha; }

    public LocalTime getHora() { return hora; }
    public void setHora(LocalTime hora) { this.hora = hora; }

    public String getDistancia() { return distancia; }
    public void setDistancia(String distancia) { this.distancia = distancia; }

    public EstadoCarrera getEstado() { return estado; }
    public void setEstado(EstadoCarrera estado) { this.estado = estado; }

    public List<Participante> getParticipantes() { return participantes; }
    public void setParticipantes(List<Participante> participantes) { this.participantes = participantes; }

    public Resultado getResultado() { return resultado; }
    public void setResultado(Resultado resultado) { this.resultado = resultado; }

    public int getMinimoParticipantes() { return minimoParticipantes; }
    public void setMinimoParticipantes(int minimoParticipantes) { this.minimoParticipantes = minimoParticipantes; }

    public int getMaximoParticipantes() { return maximoParticipantes; }
    public void setMaximoParticipantes(int maximoParticipantes) { this.maximoParticipantes = maximoParticipantes; }

    @Override
    public String toString() {
        return String.format("Carrera: %s - %s %s (%s) - Participantes: %d - Estado: %s",
                nombre, fecha, hora, distancia, participantes.size(), estado);
    }
}


package mx.uv.feaa.model;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Representa un criador de caballos en el sistema (hereda de Usuario)
 */
public class Criador extends Usuario {
    private String licenciaCriador;
    private LocalDate fechaVigenciaLicencia;
    private List<Caballo> caballos;
    private String direccion;
    private String telefono;
    private String nombreHaras;
    private int caballosRegistrados;
    private int caballosActivos;

    // Constructor
    public Criador() {
        super();
        this.caballos = new ArrayList<>();
        this.caballosRegistrados = 0;
        this.caballosActivos = 0;
    }

    public Criador(String nombreUsuario, String email, String licenciaCriador,
                   LocalDate fechaVigenciaLicencia, String direccion, String telefono, String nombreHaras) {
        super(nombreUsuario, email);
        this.licenciaCriador = licenciaCriador;
        this.fechaVigenciaLicencia = fechaVigenciaLicencia;
        this.direccion = direccion;
        this.telefono = telefono;
        this.nombreHaras = nombreHaras;
        this.caballos = new ArrayList<>();
        this.caballosRegistrados = 0;
        this.caballosActivos = 0;
    }

    // Métodos de negocio
    /**
     * Valida si la licencia del criador está vigente
     */
    public boolean validarLicencia() {
        if (licenciaCriador == null || licenciaCriador.trim().isEmpty()) {
            return false;
        }

        if (fechaVigenciaLicencia == null) {
            return false;
        }

        LocalDate ahora = LocalDate.now();
        return !fechaVigenciaLicencia.isBefore(ahora);
    }

    /**
     * Registra un nuevo caballo
     */
    public boolean registrarCaballo(Caballo caballo) {
        if (caballo == null) {
            return false;
        }

        // Validar que la licencia esté vigente
        if (!validarLicencia()) {
            return false;
        }

        // Validar que la cuenta esté activa
        if (!isActivo()) {
            return false;
        }

        // Verificar que no esté ya registrado
        if (caballos.contains(caballo)) {
            return false;
        }

        // Validar datos básicos del caballo
        if (caballo.getId() == null || caballo.getId().trim().isEmpty() ||
                caballo.getNombre() == null || caballo.getNombre().trim().isEmpty() ||
                caballo.getFechaNacimiento() == null) {
            return false;
        }

        // Agregar el caballo
        caballos.add(caballo);
        caballosRegistrados++;
        actualizarContadorActivos();

        return true;
    }

    /**
     * Actualiza la información de un caballo
     */
    public boolean actualizarInfoCaballo(Caballo caballo) {
        if (caballo == null || !validarLicencia() || !isActivo()) {
            return false;
        }

        // Buscar el caballo en la lista
        for (int i = 0; i < caballos.size(); i++) {
            if (caballos.get(i).equals(caballo)) {
                caballos.set(i, caballo);
                actualizarContadorActivos();
                return true;
            }
        }

        return false;
    }

    /**
     * Consulta el historial de carreras de un caballo específico
     */
    public List<HistorialCarrera> consultarHistorialCaballo(Caballo caballo) {
        if (caballo == null || !caballos.contains(caballo)) {
            return new ArrayList<>();
        }

        return caballo.getHistorialCarreras();
    }

    /**
     * Obtiene todos los caballos del criador
     */
    public List<Caballo> obtenerCaballos() {
        return new ArrayList<>(caballos);
    }

    /**
     * Obtiene caballos activos (que pueden participar)
     */
    public List<Caballo> obtenerCaballosActivos() {
        return caballos.stream()
                .filter(Caballo::puedeParticipar)
                .collect(Collectors.toList());
    }

    /**
     * Obtiene caballos por edad
     */
    public List<Caballo> obtenerCaballosPorEdad(int edadMinima, int edadMaxima) {
        return caballos.stream()
                .filter(caballo -> {
                    int edad = caballo.getEdadEnAnios();
                    return edad >= edadMinima && edad <= edadMaxima;
                })
                .collect(Collectors.toList());
    }

    /**
     * Obtiene caballos debutantes
     */
    public List<Caballo> obtenerCaballosDebutantes() {
        return caballos.stream()
                .filter(Caballo::esDebutante)
                .collect(Collectors.toList());
    }

    /**
     * Obtiene caballos veteranos
     */
    public List<Caballo> obtenerCaballosVeteranos() {
        return caballos.stream()
                .filter(Caballo::esVeterano)
                .collect(Collectors.toList());
    }

    /**
     * Busca un caballo por ID
     */
    public Caballo buscarCaballo(String id) {
        return caballos.stream()
                .filter(caballo -> caballo.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    /**
     * Busca caballos por nombre (búsqueda parcial)
     */
    public List<Caballo> buscarCaballosPorNombre(String nombre) {
        if (nombre == null || nombre.trim().isEmpty()) {
            return new ArrayList<>();
        }

        String nombreBusqueda = nombre.toLowerCase().trim();
        return caballos.stream()
                .filter(caballo -> caballo.getNombre().toLowerCase().contains(nombreBusqueda))
                .collect(Collectors.toList());
    }

    /**
     * Actualiza el contador de caballos activos
     */
    private void actualizarContadorActivos() {
        this.caballosActivos = (int) caballos.stream()
                .filter(Caballo::puedeParticipar)
                .count();
    }

    /**
     * Obtiene estadísticas del criador
     */
    public String obtenerEstadisticas() {
        int totalCarreras = caballos.stream()
                .mapToInt(caballo -> caballo.getHistorialCarreras().size())
                .sum();

        int totalVictorias = caballos.stream()
                .mapToInt(caballo -> (int) caballo.getHistorialCarreras().stream()
                        .filter(HistorialCarrera::esVictoria)
                        .count())
                .sum();

        return String.format(
                "Estadísticas del Criador '%s':\n" +
                        "- Haras: %s\n" +
                        "- Caballos registrados: %d\n" +
                        "- Caballos activos: %d\n" +
                        "- Total de carreras: %d\n" +
                        "- Total de victorias: %d\n" +
                        "- Licencia vigente: %s",
                getNombreUsuario(), nombreHaras, caballosRegistrados, caballosActivos,
                totalCarreras, totalVictorias, validarLicencia() ? "Sí" : "No"
        );
    }

    /**
     * Renueva la licencia del criador
     */
    public boolean renovarLicencia(LocalDate nuevaFechaVigencia) {
        if (nuevaFechaVigencia != null && nuevaFechaVigencia.isAfter(LocalDate.now())) {
            this.fechaVigenciaLicencia = nuevaFechaVigencia;
            return true;
        }
        return false;
    }

    /**
     * Verifica si puede registrar más caballos
     */
    public boolean puedeRegistrarCaballos() {
        return validarLicencia() && isActivo();
    }

    // Getters y Setters
    public String getLicenciaCriador() { return licenciaCriador; }
    public void setLicenciaCriador(String licenciaCriador) { this.licenciaCriador = licenciaCriador; }

    public LocalDate getFechaVigenciaLicencia() { return fechaVigenciaLicencia; }
    public void setFechaVigenciaLicencia(LocalDate fechaVigenciaLicencia) {
        this.fechaVigenciaLicencia = fechaVigenciaLicencia;
    }

    public List<Caballo> getCaballos() { return new ArrayList<>(caballos); }
    public void setCaballos(List<Caballo> caballos) {
        this.caballos = caballos != null ? new ArrayList<>(caballos) : new ArrayList<>();
        this.caballosRegistrados = this.caballos.size();
        actualizarContadorActivos();
    }

    public String getDireccion() { return direccion; }
    public void setDireccion(String direccion) { this.direccion = direccion; }

    public String getTelefono() { return telefono; }
    public void setTelefono(String telefono) { this.telefono = telefono; }

    public String getNombreHaras() { return nombreHaras; }
    public void setNombreHaras(String nombreHaras) { this.nombreHaras = nombreHaras; }

    public int getCaballosRegistrados() { return caballosRegistrados; }
    public int getCaballosActivos() { return caballosActivos; }

    @Override
    public String toString() {
        return String.format("Criador{usuario='%s', haras='%s', caballos=%d, licencia='%s', vigente=%s}",
                getNombreUsuario(), nombreHaras, caballosRegistrados, licenciaCriador,
                validarLicencia() ? "Sí" : "No");
    }
}

package mx.uv.feaa.model;

import java.time.LocalTime;

public class EstadisticasRendimiento {
    private int totalCarreras;
    private int victorias;
    private int colocaciones;
    private LocalTime promedioTiempo;
    private double porcentajeVictorias;

    // Constructor
    public EstadisticasRendimiento() {
        this.totalCarreras = 0;
        this.victorias = 0;
        this.colocaciones = 0;
        this.promedioTiempo = LocalTime.of(0, 0, 0);
        this.porcentajeVictorias = 0.0;
    }

    public EstadisticasRendimiento(int totalCarreras, int victorias, int colocaciones) {
        this.totalCarreras = totalCarreras;
        this.victorias = victorias;
        this.colocaciones = colocaciones;
        this.porcentajeVictorias = totalCarreras > 0 ? (double) victorias / totalCarreras * 100 : 0.0;
    }

    // Métodos de cálculo
    public void actualizarEstadisticas(boolean gano, boolean coloco, LocalTime tiempo) {
        this.totalCarreras++;
        if (gano) {
            this.victorias++;
        }
        if (coloco) {
            this.colocaciones++;
        }
        this.porcentajeVictorias = (double) victorias / totalCarreras * 100;
        // Actualizar promedio de tiempo (simplificado)
        if (tiempo != null) {
            this.promedioTiempo = tiempo; // En una implementación real, calcularíamos el promedio
        }
    }

    // Getters y Setters
    public int getTotalCarreras() {
        return totalCarreras;
    }

    public void setTotalCarreras(int totalCarreras) {
        this.totalCarreras = totalCarreras;
    }

    public int getVictorias() {
        return victorias;
    }

    public void setVictorias(int victorias) {
        this.victorias = victorias;
    }

    public int getColocaciones() {
        return colocaciones;
    }

    public void setColocaciones(int colocaciones) {
        this.colocaciones = colocaciones;
    }

    public LocalTime getPromedioTiempo() {
        return promedioTiempo;
    }

    public void setPromedioTiempo(LocalTime promedioTiempo) {
        this.promedioTiempo = promedioTiempo;
    }

    public double getPorcentajeVictorias() {
        return porcentajeVictorias;
    }

    public void setPorcentajeVictorias(double porcentajeVictorias) {
        this.porcentajeVictorias = porcentajeVictorias;
    }

    @Override
    public String toString() {
        return String.format("Estadísticas: %d carreras, %d victorias (%.1f%%), %d colocaciones",
                totalCarreras, victorias, porcentajeVictorias, colocaciones);
    }
}

package mx.uv.feaa.model;

import java.time.LocalDate;
import java.time.LocalTime;

public class HistorialCarrera {
    private String carreraId;
    private String nombreCarrera;
    private Integer posicion;
    private LocalTime tiempo;
    private LocalDate fecha;
    private String hipodromo;

    // Constructor
    public HistorialCarrera(Carrera carrera, Integer posicion, LocalTime tiempo, LocalDate fecha) {}

    public HistorialCarrera(String carreraId, String nombreCarrera, Integer posicion,
                            LocalTime tiempo, LocalDate fecha, String hipodromo) {
        this.carreraId = carreraId;
        this.nombreCarrera = nombreCarrera;
        this.posicion = posicion;
        this.tiempo = tiempo;
        this.fecha = fecha;
        this.hipodromo = hipodromo;
    }

    // Métodos de utilidad
    public boolean esVictoria() {
        return posicion != null && posicion == 1;
    }

    public boolean esColocacion() {
        return posicion != null && posicion <= 3;
    }

    // Getters y Setters
    public String getCarreraId() {
        return carreraId;
    }

    public void setCarreraId(String carreraId) {
        this.carreraId = carreraId;
    }

    public String getNombreCarrera() {
        return nombreCarrera;
    }

    public void setNombreCarrera(String nombreCarrera) {
        this.nombreCarrera = nombreCarrera;
    }

    public Integer getPosicion() {
        return posicion;
    }

    public void setPosicion(Integer posicion) {
        this.posicion = posicion;
    }

    public LocalTime getTiempo() {
        return tiempo;
    }

    public void setTiempo(LocalTime tiempo) {
        this.tiempo = tiempo;
    }

    public LocalDate getFecha() {
        return fecha;
    }

    public void setFecha(LocalDate fecha) {
        this.fecha = fecha;
    }

    public String getHipodromo() {
        return hipodromo;
    }

    public void setHipodromo(String hipodromo) {
        this.hipodromo = hipodromo;
    }

    @Override
    public String toString() {
        return String.format("%s - Posición: %d, Tiempo: %s (%s)",
                nombreCarrera, posicion, tiempo, fecha);
    }
}

package mx.uv.feaa.model;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

public class Jinete {
    private String id;
    private String nombre;
    private LocalDate fechaNacimiento;
    private double peso;
    private String licencia;
    private LocalDate fechaVigenciaLicencia;
    private List<HistorialCarrera> historialCarreras;
    private EstadisticasRendimiento estadisticas;

    // Constantes
    private static final double PESO_MINIMO_JINETE = 50.0; // kg
    private static final double PESO_MAXIMO_JINETE = 57.0; // kg
    private static final int EDAD_MINIMA_JINETE = 16; // años

    // Constructor
    public Jinete() {
        this.historialCarreras = new ArrayList<>();
        this.estadisticas = new EstadisticasRendimiento();
    }

    public Jinete(String id, String nombre, LocalDate fechaNacimiento,
                  double peso, String licencia, LocalDate fechaVigenciaLicencia) {
        this();
        this.id = id;
        this.nombre = nombre;
        this.fechaNacimiento = fechaNacimiento;
        this.peso = peso;
        this.licencia = licencia;
        this.fechaVigenciaLicencia = fechaVigenciaLicencia;
    }

    // Métodos de negocio
    public boolean validarLicencia() {
        if (licencia == null || licencia.trim().isEmpty()) {
            return false;
        }

        if (fechaVigenciaLicencia == null) {
            return false;
        }

        LocalDate ahora = LocalDate.now();
        return !fechaVigenciaLicencia.isBefore(ahora);
    }

    public boolean validarPesoReglamentario(double pesoAsignado) {
        // El peso del jinete debe estar dentro del rango reglamentario
        if (peso < PESO_MINIMO_JINETE || peso > PESO_MAXIMO_JINETE) {
            return false;
        }

        // El peso asignado debe ser alcanzable por el jinete
        // (considerando un margen de +/- 2 kg)
        double diferencia = Math.abs(peso - pesoAsignado);
        return diferencia <= 2.0;
    }

    public boolean validarEdadMinima() {
        LocalDate ahora = LocalDate.now();
        long edadEnAnios = ChronoUnit.YEARS.between(fechaNacimiento, ahora);
        return edadEnAnios >= EDAD_MINIMA_JINETE;
    }

    public boolean puedeParticipar() {
        return validarLicencia() && validarEdadMinima() &&
                peso >= PESO_MINIMO_JINETE && peso <= PESO_MAXIMO_JINETE;
    }

    public EstadisticasRendimiento obtenerEstadisticas() {
        // Recalcular estadísticas basadas en el historial
        int totalCarreras = historialCarreras.size();
        int victorias = (int) historialCarreras.stream()
                .mapToInt(h -> h.esVictoria() ? 1 : 0)
                .sum();
        int colocaciones = (int) historialCarreras.stream()
                .mapToInt(h -> h.esColocacion() ? 1 : 0)
                .sum();

        this.estadisticas = new EstadisticasRendimiento(totalCarreras, victorias, colocaciones);
        return this.estadisticas;
    }

    public void agregarHistorialCarrera(HistorialCarrera historial) {
        if (historial != null) {
            this.historialCarreras.add(historial);
            // Actualizar estadísticas
            obtenerEstadisticas();
        }
    }

    public int getEdadEnAnios() {
        return (int) ChronoUnit.YEARS.between(fechaNacimiento, LocalDate.now());
    }

    // Getters y Setters
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public LocalDate getFechaNacimiento() {
        return fechaNacimiento;
    }

    public void setFechaNacimiento(LocalDate fechaNacimiento) {
        this.fechaNacimiento = fechaNacimiento;
    }

    public double getPeso() {
        return peso;
    }

    public void setPeso(double peso) {
        this.peso = peso;
    }

    public String getLicencia() {
        return licencia;
    }

    public void setLicencia(String licencia) {
        this.licencia = licencia;
    }

    public LocalDate getFechaVigenciaLicencia() {
        return fechaVigenciaLicencia;
    }

    public void setFechaVigenciaLicencia(LocalDate fechaVigenciaLicencia) {
        this.fechaVigenciaLicencia = fechaVigenciaLicencia;
    }

    public List<HistorialCarrera> getHistorialCarreras() {
        return new ArrayList<>(historialCarreras);
    }

    public void setHistorialCarreras(List<HistorialCarrera> historialCarreras) {
        this.historialCarreras = historialCarreras != null ?
                new ArrayList<>(historialCarreras) : new ArrayList<>();
    }

    public void agregarHistorial(HistorialCarrera historial) {
        agregarHistorialCarrera(historial);
    }

    public EstadisticasRendimiento getEstadisticas() {
        return estadisticas;
    }

    public void setEstadisticas(EstadisticasRendimiento estadisticas) {
        this.estadisticas = estadisticas;
    }

    @Override
    public String toString() {
        return String.format("Jinete{id='%s', nombre='%s', edad=%d años, peso=%.1f kg, licencia='%s'}",
                id, nombre, getEdadEnAnios(), peso, licencia);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Jinete jinete = (Jinete) obj;
        return id != null ? id.equals(jinete.id) : jinete.id == null;
    }

    @Override
    public int hashCode() {
        return id != null ? id.hashCode() : 0;
    }
}

package mx.uv.feaa.model;

import mx.uv.feaa.enumeracion.EstadoParticipante;

/**
 * Representa un participante en una carrera (combinación de jinete y caballo)
 */
public class Participante {
    private int numeroCompetidor;
    private double pesoAsignado;
    private Caballo caballo;
    private Jinete jinete;
    private EstadoParticipante estado;

    // Constructor
    public Participante(int numeroCompetidor, double pesoAsignado, Caballo caballo, Jinete jinete) {
        this.numeroCompetidor = numeroCompetidor;
        this.pesoAsignado = pesoAsignado;
        this.caballo = caballo;
        this.jinete = jinete;
        this.estado = EstadoParticipante.INSCRITO;
    }

    /**
     * Valida si el participante es elegible para competir
     */
    public boolean validarElegibilidad() {
        // Validar que el caballo pueda participar
        if (caballo == null || !caballo.puedeParticipar()) {
            return false;
        }

        // Validar que el jinete tenga licencia válida
        if (jinete == null || !jinete.validarLicencia()) {
            return false;
        }

        // Validar peso reglamentario del jinete
        if (!jinete.validarPesoReglamentario(pesoAsignado)) {
            return false;
        }

        // Validar que el estado permita participar
        if (!estado.puedeParticipar()) {
            return false;
        }

        // Validar número de competidor válido
        if (numeroCompetidor <= 0) {
            return false;
        }

        // Validar peso asignado dentro de límites
        if (pesoAsignado < 50 || pesoAsignado > 65) { // Límites típicos en kg
            return false;
        }

        return true;
    }

    /**
     * Obtiene el rendimiento histórico combinado del jinete y caballo
     */
    public EstadisticasRendimiento obtenerRendimientoHistorico() {
        EstadisticasRendimiento rendimientoJinete = jinete.obtenerEstadisticas();
        EstadisticasRendimiento rendimientoCaballo = caballo.obtenerRendimiento();

        // Validar que ambos tengan estadísticas
        if (rendimientoJinete == null) {
            rendimientoJinete = new EstadisticasRendimiento();
        }
        if (rendimientoCaballo == null) {
            rendimientoCaballo = new EstadisticasRendimiento();
        }

        // Combinar estadísticas con peso ponderado
        // 60% peso del jinete, 40% peso del caballo
        int totalCarreras = Math.max(rendimientoJinete.getTotalCarreras(), rendimientoCaballo.getTotalCarreras());

        // Calcular victorias ponderadas
        int victoriasJinete = rendimientoJinete.getVictorias();
        int victoriasCaballo = rendimientoCaballo.getVictorias();
        int totalVictorias = (int) Math.round((victoriasJinete * 0.6) + (victoriasCaballo * 0.4));

        // Calcular colocaciones ponderadas
        int colocacionesJinete = rendimientoJinete.getColocaciones();
        int colocacionesCaballo = rendimientoCaballo.getColocaciones();
        int totalColocaciones = (int) Math.round((colocacionesJinete * 0.6) + (colocacionesCaballo * 0.4));

        return new EstadisticasRendimiento(totalCarreras, totalVictorias, totalColocaciones);
    }

    /**
     * Calcula la experiencia combinada del participante
     */
    public int obtenerExperienciaCombinada() {
        EstadisticasRendimiento rendimientoJinete = jinete.obtenerEstadisticas();
        EstadisticasRendimiento rendimientoCaballo = caballo.obtenerRendimiento();

        int experienciaJinete = rendimientoJinete != null ? rendimientoJinete.getTotalCarreras() : 0;
        int experienciaCaballo = rendimientoCaballo != null ? rendimientoCaballo.getTotalCarreras() : 0;

        return experienciaJinete + experienciaCaballo;
    }

    /**
     * Verifica si es la primera carrera juntos
     */
    public boolean esPrimeraCarreraJuntos() {
        // Buscar en el historial del caballo si ya corrió con este jinete
        for (HistorialCarrera historial : caballo.getHistorialCarreras()) {
            // Esta lógica requeriría que HistorialCarrera tenga referencia al jinete
            // Por ahora, asumimos que es su primera carrera juntos si no hay historial
        }
        return true; // Simplificado por ahora
    }

    /**
     * Actualiza el estado del participante
     */
    public boolean actualizarEstado(EstadoParticipante nuevoEstado) {
        if (nuevoEstado == null) {
            return false;
        }

        // Validar transiciones de estado válidas
        switch (estado) {
            case INSCRITO:
                if (nuevoEstado == EstadoParticipante.CONFIRMADO ||
                        nuevoEstado == EstadoParticipante.RETIRADO) {
                    estado = nuevoEstado;
                    return true;
                }
                break;
            case CONFIRMADO:
                if (nuevoEstado == EstadoParticipante.PESADO ||
                        nuevoEstado == EstadoParticipante.RETIRADO) {
                    estado = nuevoEstado;
                    return true;
                }
                break;
            case PESADO:
                if (nuevoEstado == EstadoParticipante.EN_PISTA ||
                        nuevoEstado == EstadoParticipante.RETIRADO) {
                    estado = nuevoEstado;
                    return true;
                }
                break;
            case EN_PISTA:
                if (nuevoEstado == EstadoParticipante.FINALIZADO ||
                        nuevoEstado == EstadoParticipante.DESCALIFICADO) {
                    estado = nuevoEstado;
                    return true;
                }
                break;
        }
        return false;
    }

    // Getters y Setters
    public int getNumeroCompetidor() { return numeroCompetidor; }
    public void setNumeroCompetidor(int numeroCompetidor) {
        if (numeroCompetidor > 0) {
            this.numeroCompetidor = numeroCompetidor;
        }
    }

    public double getPesoAsignado() { return pesoAsignado; }
    public void setPesoAsignado(double pesoAsignado) {
        if (pesoAsignado >= 50 && pesoAsignado <= 65) {
            this.pesoAsignado = pesoAsignado;
        }
    }

    public Caballo getCaballo() { return caballo; }
    public void setCaballo(Caballo caballo) { this.caballo = caballo; }

    public Jinete getJinete() { return jinete; }
    public void setJinete(Jinete jinete) { this.jinete = jinete; }

    public EstadoParticipante getEstado() { return estado; }
    public void setEstado(EstadoParticipante estado) { this.estado = estado; }

    @Override
    public String toString() {
        return String.format("Participante #%d: %s montando a %s (Peso: %.1f kg) - Estado: %s",
                numeroCompetidor,
                jinete != null ? jinete.getNombre() : "N/A",
                caballo != null ? caballo.getNombre() : "N/A",
                pesoAsignado,
                estado != null ? estado.getDescripcion() : "N/A");
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Participante that = (Participante) obj;
        return numeroCompetidor == that.numeroCompetidor;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(numeroCompetidor);
    }
}

package mx.uv.feaa.model;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Representa el resultado de una carrera
 */
public class Resultado {
    private Carrera carrera;
    private Map<Integer, Participante> posiciones;
    private Map<Participante, LocalTime> tiemposOficiales;
    private LocalDate fechaRegistro;

    // Constructor
    public Resultado(Carrera carrera) {
        this.carrera = carrera;
        this.posiciones = new HashMap<>();
        this.tiemposOficiales = new HashMap<>();
        this.fechaRegistro = LocalDate.now();
    }

    /**
     * Registra la posición de un participante
     */
    public void registrarPosicion(int posicion, Participante participante, LocalTime tiempo) {
        posiciones.put(posicion, participante);
        tiemposOficiales.put(participante, tiempo);
    }

    /**
     * Obtiene el ganador de la carrera (primera posición)
     */
    public Participante obtenerGanador() {
        return posiciones.get(1);
    }

    /**
     * Obtiene la posición de un participante específico
     */
    public Integer obtenerPosicion(Participante participante) {
        for (Map.Entry<Integer, Participante> entry : posiciones.entrySet()) {
            if (entry.getValue().equals(participante)) {
                return entry.getKey();
            }
        }
        return null;
    }

    /**
     * Obtiene el participante en una posición específica
     */
    public Participante obtenerParticipantePorPosicion(int posicion) {
        return posiciones.get(posicion);
    }

    /**
     * Obtiene el tiempo oficial de un participante
     */
    public LocalTime obtenerTiempo(Participante participante) {
        return tiemposOficiales.get(participante);
    }

    /**
     * Verifica si los resultados están completos
     */
    public boolean esCompleto() {
        return posiciones.size() == carrera.getParticipantes().size() &&
                tiemposOficiales.size() == carrera.getParticipantes().size();
    }

    // Getters y Setters
    public Carrera getCarrera() {
        return carrera; }
    public void setCarrera(Carrera carrera) {
        this.carrera = carrera; }

    public Map<Integer, Participante> getPosiciones() {
        return posiciones; }
    public void setPosiciones(Map<Integer, Participante> posiciones) {
        this.posiciones = posiciones;
    }

    public Map<Participante, LocalTime> getTiemposOficiales() {
        return tiemposOficiales;
    }
    public void setTiemposOficiales(Map<Participante, LocalTime> tiemposOficiales) {
        this.tiemposOficiales = tiemposOficiales;
    }

    public LocalDate getFechaRegistro() {
        return fechaRegistro; }
    public void setFechaRegistro(LocalDate fechaRegistro) {
        this.fechaRegistro = fechaRegistro;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Resultado de la carrera: ").append(carrera.getNombre()).append("\n");
        sb.append("Fecha: ").append(fechaRegistro).append("\n");
        sb.append("Posiciones:\n");

        for (int i = 1; i <= posiciones.size(); i++) {
            Participante p = posiciones.get(i);
            if (p != null) {
                LocalTime tiempo = tiemposOficiales.get(p);
                sb.append(String.format("%d. %s - Tiempo: %s\n", i, p.toString(), tiempo));
            }
        }

        return sb.toString();
    }
}

package mx.uv.feaa.model;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Representa el resultado de una carrera
 */
public class Resultado {
    private Carrera carrera;
    private Map<Integer, Participante> posiciones;
    private Map<Participante, LocalTime> tiemposOficiales;
    private LocalDate fechaRegistro;

    // Constructor
    public Resultado(Carrera carrera) {
        this.carrera = carrera;
        this.posiciones = new HashMap<>();
        this.tiemposOficiales = new HashMap<>();
        this.fechaRegistro = LocalDate.now();
    }

    /**
     * Registra la posición de un participante
     */
    public void registrarPosicion(int posicion, Participante participante, LocalTime tiempo) {
        posiciones.put(posicion, participante);
        tiemposOficiales.put(participante, tiempo);
    }

    /**
     * Obtiene el ganador de la carrera (primera posición)
     */
    public Participante obtenerGanador() {
        return posiciones.get(1);
    }

    /**
     * Obtiene la posición de un participante específico
     */
    public Integer obtenerPosicion(Participante participante) {
        for (Map.Entry<Integer, Participante> entry : posiciones.entrySet()) {
            if (entry.getValue().equals(participante)) {
                return entry.getKey();
            }
        }
        return null;
    }

    /**
     * Obtiene el participante en una posición específica
     */
    public Participante obtenerParticipantePorPosicion(int posicion) {
        return posiciones.get(posicion);
    }

    /**
     * Obtiene el tiempo oficial de un participante
     */
    public LocalTime obtenerTiempo(Participante participante) {
        return tiemposOficiales.get(participante);
    }

    /**
     * Verifica si los resultados están completos
     */
    public boolean esCompleto() {
        return posiciones.size() == carrera.getParticipantes().size() &&
                tiemposOficiales.size() == carrera.getParticipantes().size();
    }

    // Getters y Setters
    public Carrera getCarrera() {
        return carrera; }
    public void setCarrera(Carrera carrera) {
        this.carrera = carrera; }

    public Map<Integer, Participante> getPosiciones() {
        return posiciones; }
    public void setPosiciones(Map<Integer, Participante> posiciones) {
        this.posiciones = posiciones;
    }

    public Map<Participante, LocalTime> getTiemposOficiales() {
        return tiemposOficiales;
    }
    public void setTiemposOficiales(Map<Participante, LocalTime> tiemposOficiales) {
        this.tiemposOficiales = tiemposOficiales;
    }

    public LocalDate getFechaRegistro() {
        return fechaRegistro; }
    public void setFechaRegistro(LocalDate fechaRegistro) {
        this.fechaRegistro = fechaRegistro;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Resultado de la carrera: ").append(carrera.getNombre()).append("\n");
        sb.append("Fecha: ").append(fechaRegistro).append("\n");
        sb.append("Posiciones:\n");

        for (int i = 1; i <= posiciones.size(); i++) {
            Participante p = posiciones.get(i);
            if (p != null) {
                LocalTime tiempo = tiemposOficiales.get(p);
                sb.append(String.format("%d. %s - Tiempo: %s\n", i, p.toString(), tiempo));
            }
        }

        return sb.toString();
    }
}
